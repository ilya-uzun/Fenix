

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* если на обоих входих истина, запускается таймер и по истечении
 указаного времяни присваивает зничение на Out=true .
AlarmAND_FB_Res сбросит Out на false на оба выхода если первое условие and не выполняется*)
FUNCTION_BLOCK AlarmAND_FB
VAR_INPUT
	input: BOOL;
	inversion : BOOL;
END_VAR
VAR_OUTPUT
	bError: BOOL;
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT  inversion AND input
THEN ton1.IN := TRUE; (*инверсия*)
ELSE  ton1.IN := FALSE;
END_IF

TON1(PT:= T#15s);

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:= b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (sema1.BUSY, FALSE, TRUE);

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Block_FB (*запоминает аварию после 3 сек и запоминает, сброс restar (блок)*)
VAR_INPUT
	input: BOOL;

END_VAR
VAR_OUTPUT
	bError: BOOL; (*Лакальная переменная*)
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
TON1(
	IN:=input ,
	PT:= T#5s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (sema1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ErrorBurner_FB
VAR_INPUT
	start : BOOL;
	lampWork : BOOL;
	lampAlarm : BOOL;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR
VAR
	TON : TON;
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
IF start AND NOT lampWork
THEN ton.in := TRUE;
ELSE ton.in := FALSE;
END_IF

TON(PT:= t#120s );

IF ton.q OR lampAlarm
THEN TON1.in := TRUE;
ELSE TON1.in := FALSE;
END_IF


TON1(
	PT:= T#5s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

error := SEL (sema1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK InvAlarm_FB
VAR_INPUT
	inversion: BOOL;
END_VAR
VAR_OUTPUT
	bError: BOOL;
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)

ton1.IN := SEL (inversion, TRUE, FALSE);  (*инверсия*)

TON1(PT:= T#3s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (SEMA1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK UZnoReady_FB (*Неисправность цепей вентилятора обдува*)
VAR_INPUT
	bStart: BOOL;
	bRediness : BOOL; (*Готовность*)
END_VAR
VAR_OUTPUT
	bError : BOOL;
END_VAR
VAR
	SEMA : SEMA;
	TON: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(*Если после старта нет готовности - авария*)

ton(
	IN:= bStart,
	PT:= T#40s);

IF   ton.Q AND NOT bRediness
THEN sema.CLAIM := TRUE;
ELSE sema.CLAIM := FALSE;
END_IF

sema(RELEASE:= b0x0 );

bError := SEL (sema.BUSY, FALSE, TRUE);

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Warning_FB
VAR_INPUT
	input : BOOL;
END_VAR
VAR_OUTPUT
	bWarning: BOOL;
END_VAR
VAR
	TON1 : TON;
END_VAR
(* @END_DECLARATION := '0' *)
TON1(
	IN:=input ,
	PT:= T#5s  );

bWarning := SEL (TON1.Q, FALSE, TRUE );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FanObduva_FB
VAR_INPUT
	bRun : BOOL;
	bModeMax : BOOL; (*задание на изменение скорости*)
END_VAR
VAR_OUTPUT
	bOutStart: BOOL;
	wRate : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF bRun AND NOT bModeMax
THEN bOutStart := TRUE; wRate := 35;
ELSIF bRun AND  bModeMax
THEN bOutStart := TRUE; wRate := 50;
ELSE  bOutStart := FALSE; wRate := 0;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Gen_Impuls
VAR_INPUT
	enq : BOOL := TRUE;
	PTH : TIME;
	PTL : TIME;
END_VAR
VAR_OUTPUT
	Q : BOOL;
END_VAR
VAR
	tx : TIME;
	tn : TIME;
	init : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF enq THEN
	tx := DWORD_TO_TIME(T_PLC_MS(debug:=0, N :=0, offset :=0));
	IF NOT init THEN init := TRUE; tn := tx; END_IF;
	IF tx - tn >= SEL(Q, PTL, PTH) THEN
		tn := tn + SEL(Q, PTL, PTH);
		Q := NOT Q;
	END_IF;
ELSE
	Q := FALSE;
	init := FALSE;
END_IF;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Heating_FB
VAR_INPUT
	byMode_FB : BYTE;

	wTempCO : REAL;
	wYstPanel : WORD;
	bErrorHeating : BOOL;
	bErrorVolveAir : BOOL;

END_VAR
VAR_OUTPUT
	bHeatingEneble :BOOL;
	bHeatingOff :BOOL;
	bVolveAirEneble :BOOL;
END_VAR
VAR
	wYstavkaCO :WORD;
	bVolve : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)

IF wYstPanel = 0
THEN wYstavkaCO := 25; (*уставка темп в СО по умолчанию*)
ELSE wYstavkaCO:= wYstPanel;
END_IF

	 IF  bErrorHeating OR bVolve
	THEN bHeatingOff := TRUE; bHeatingEneble:= FALSE;
	ELSIF   wTempCO < wYstavkaCO - 1  AND byMode_FB = 0
	THEN bHeatingEneble := TRUE; bHeatingOff := FALSE; bVolveAirEneble := FALSE;
	ELSIF wTempCO > wYstavkaCO + 1
	THEN bHeatingEneble:= FALSE; bHeatingOff := TRUE;
	END_IF

IF  byMode_FB = 1 OR byMode_FB = 2 OR byMode_FB = 3
THEN bVolve := TRUE;
ELSE bVolve := FALSE;
END_IF

	IF wTempCO < wYstavkaCO -1 AND NOT bErrorVolveAir AND bVolve
	THEN bVolveAirEneble := TRUE; bHeatingEneble := FALSE; bHeatingOff := TRUE;
	ELSIF   wTempCO > wYstavkaCO + 1 AND NOT bErrorVolveAir
	THEN bVolveAirEneble:= FALSE;
	END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Mode5_15
VAR_INPUT
	bSignalSAY : BOOL; (*сигналы на смену режима*)
	bSignalDiscret : BOOL;

	bWork1 : BOOL; (*работать по выходу*)
	bWork2 : BOOL; (*работать по темп в помещении*)
	reTempRoom : REAL;
	reTempExit : REAL;

	wPanelZad1 : WORD; (*задание для окошка ввода значения на панели*)
	wPanelZad2 : WORD;
END_VAR
VAR_OUTPUT
	bPanelTableZad : BOOL; (*Инфо. на панель о смене режима*)
	bPanelTable5_15 : BOOL;
	wZadaniePID_FB: WORD;
	wYstavkaPID_FB : WORD;
	wZad : WORD; (*внутринние задания*)

END_VAR
VAR
	R_TRIG15 :R_TRIG;
	R_TRIG5 :R_TRIG;

END_VAR

(* @END_DECLARATION := '0' *)
(*режим +5 +15 *)
(*бит уведомления задать на прямую т.к. требуется его сброс на панели*)
IF b0x152
THEN bPanelTableZad := TRUE; (*Отк задание по умолчание*)
ELSE bPanelTableZad := FALSE;
END_IF

	IF bSignalDiscret OR bSignalSAY
	THEN wZad := 15;  bPanelTable5_15 := TRUE;
	ELSIF NOT bSignalDiscret AND NOT bSignalSAY
	THEN wZad := 5;  bPanelTable5_15 := FALSE;
	END_IF

IF  bSignalDiscret OR  bSignalSAY(*есть согнал от САУ то включить +15*)
THEN  R_TRIG15.CLK := TRUE;
ELSE R_TRIG15.CLK  := FALSE;
END_IF

IF NOT bSignalDiscret AND NOT bSignalSAY(*если нет согнала то вллючить +5*)
THEN R_TRIG5.CLK  := TRUE;
ELSE R_TRIG5.CLK  := FALSE;
END_IF
(*сброс бита с панели b0x152 *)
R_TRIG15();

R_TRIG5();

IF  R_TRIG15.Q OR R_TRIG5.Q
THEN b0x152 := FALSE;
END_IF

(*задание температуры на ПИД*)
IF bWork1
THEN  wZadaniePID_FB:= wPanelZad1;
ELSIF bWork2
THEN   wZadaniePID_FB:=  wPanelZad2;
ELSE wZadaniePID_FB:= wZad; wZadaniePID_FB:=  wZad; (*присвоить врутренее задание*)
END_IF

(*Уставка на ПИД*)
IF bWork1
THEN  wYstavkaPID_FB:= REAL_TO_WORD  (reTempExit);
ELSIF bWork2
THEN   wYstavkaPID_FB:= REAL_TO_WORD (reTempRoom);
ELSE  wYstavkaPID_FB:= REAL_TO_WORD  (reTempExit); (*по умолчании работать по дат. на выходе*)
END_IF


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK MotoHours_FB
VAR_INPUT
	bDeviceInWork: BOOL;
END_VAR
VAR_OUTPUT
	byHour : WORD;
END_VAR
VAR
	tm1: TON;
	byMinyt: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
tm1(
	PT := T#60s,
	IN := NOT tm1.Q);

byMinyt := byMinyt + BOOL_TO_WORD (tm1.Q AND bDeviceInWork);

IF byMinyt = 60 THEN (*перевод из минут в часы*)
	byHour := byHour+1;
	byMinyt := 0;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK SwBurner_FB
VAR_INPUT
	bInput1 : BOOL;
	bInput2 : BOOL;
	rZad1 : REAL;
	rZad2 : REAL;
	Y_UP : BOOL;
	Y_DOWN : BOOL;
	bInError1 : BOOL;
	bInError2 : BOOL;
	rTempTO1 : REAL;
	rTempTO2 : REAL;
END_VAR
VAR_OUTPUT
	rNod1 : REAL;
	rNod2 : REAL;
	bPIDmax1 : BOOL;
	bPIDmin1 : BOOL;
	bPIDmax2 : BOOL;
	bPIDmin2: BOOL;
	bStartPower1 : BOOL;
	bStartPower2 : BOOL;

END_VAR
VAR
	bMode : BYTE;
	bModeBurner : BYTE;
	tonIN1 : TON;
	tonIN2 : TON;
	R_TRIG1 : R_TRIG;
	R_TRIG2 : R_TRIG;
	bResetBurner : BOOL;
	TP1: TP;
END_VAR
(* @END_DECLARATION := '0' *)
(*сброс на модули задания мощности*)
R_TRIG1(CLK:= bInput1 , Q=> );
R_TRIG2(CLK:= bInput2 , Q=> );

IF R_TRIG1.Q OR R_TRIG2.Q
THEN TP1.IN := TRUE;

ELSE TP1.IN := FALSE;
END_IF
TP1( PT:= t#5s , Q=> , ET=> );
(*Пуск горелок *)
IF   bInput1 OR bInput2
THEN
(*сброс*)
IF TP1.Q
THEN bModeBurner := 0;
END_IF
	IF bInput1 AND  (rTempTO1 < 40)   AND NOT  TP1.Q AND NOT bInError1  (*гор 1*)
	THEN bModeBurner := 1;
	ELSIF bInput1 AND (rTempTO1 > 40)  AND NOT  TP1.Q AND NOT bInError1  (*разрешение на запуск второй горелки*)
	THEN bModeBurner := 4 ;
	END_IF
		IF bInput2 AND  (rTempTO2 < 40) AND NOT  TP1.Q AND NOT bInError2  (*гор 2*)
		THEN bModeBurner := 2;
		ELSIF bInput2 AND (rTempTO2 > 40) AND NOT  TP1.Q AND NOT bInError2
		THEN bModeBurner := 4 ;
		END_IF
			IF bInput1 AND NOT bInError1 AND  bInput2 AND NOT bInError2 (*запуск двух горелок*)
			THEN bModeBurner := 3 ;
			END_IF

ELSE  bModeBurner := 0 ;
END_IF

CASE bModeBurner OF
0 : bStartPower1 := FALSE; bStartPower2 := FALSE;
1 : bStartPower1 := TRUE; bStartPower2 := FALSE;
2 : bStartPower2 := TRUE; bStartPower1 := FALSE;
3 : bStartPower1 := TRUE; bStartPower2 := TRUE;
4 :  bStartPower1 := TRUE;  bStartPower2 := TRUE;
END_CASE


(*задание на горелку 1*)
tonIN1(IN:= bStartPower1, PT:= t#60s); (*выдержка для запуска горелки в работу*)
IF bStartPower1 AND tonIN1.Q AND (rTempTO1 > 40) AND NOT  TP1.Q
THEN
	IF Y_UP AND NOT Y_DOWN
	THEN bMode :=1; (*увеличение мощ гор1*)
	END_IF
		IF Y_UP AND (rZad1=100)
		THEN bMode :=2; (*запуск гор1 и 2*)
		END_IF
			IF Y_DOWN AND  (rZad1=100)
			THEN bMode :=3; (*в работе 1 и 2 горелка уменьшение мощ гор 2*)
			END_IF
				IF  Y_DOWN AND (rZad2=0)
				THEN bMode :=4; (*останов горелки 2 и уменьшение мощ гор 1*)
				END_IF
	IF bInError2 AND Y_UP  (*аварийный режим *)
	THEN bMode := 9;
	END_IF
		IF bInError2 AND Y_DOWN
		THEN bMode := 10;
		END_IF
IF PLC_PRG.Alarm.bErr70TempAir
THEN bMode := 13;
END_IF
ELSE bMode := 0;
END_IF

tonIN2(IN:= bStartPower2, PT:= t#60s);
(*задание на горелку 2*)
IF bStartPower2 AND tonIN2.Q AND (rTempTO2 > 40) AND NOT  TP1.Q
THEN
	IF Y_UP AND NOT Y_DOWN
	THEN bMode :=5;
	END_IF
		IF Y_UP AND (rZad2=100)
		THEN bMode :=6;
		END_IF
			IF Y_DOWN AND  (rZad2=100)
			THEN bMode :=7;
			END_IF
				IF  Y_DOWN AND (rZad1=0)
				THEN bMode :=8;
				END_IF
	IF bInError1 AND Y_UP (*аварийный режим *)
	THEN bMode := 11;
	END_IF
		IF bInError1 AND Y_DOWN
		THEN bMode := 12;
		END_IF
IF PLC_PRG.Alarm.bErr70TempAir
THEN bMode := 13;
END_IF
ELSE bMode := 0;
END_IF

(*reset*)
IF NOT bInput1 AND NOT  bInput2
THEN bMode := 0;
END_IF


CASE bMode OF
0 : bPIDmax1:=FALSE;bPIDmin1 :=FALSE;  bPIDmax2:=FALSE;bPIDmin2 :=FALSE; rNod1:=0; rNod2:=0;
1 : bPIDmax1:=TRUE; rNod1:=20.5; bPIDmax2:=FALSE; bPIDmin1:= FALSE; bPIDmin2 :=FALSE;
2 : bPIDmax2:=TRUE; rNod2:=20.5; bPIDmin1:= FALSE; bPIDmin2 :=FALSE;
3 : bPIDmin2 :=TRUE; rNod2:=20.5; bPIDmax1:=FALSE; bPIDmax2:=FALSE;
4 : bPIDmin1:= TRUE; rNod1:=21; bPIDmax1:=FALSE; bPIDmax2:=FALSE;bPIDmin2 :=FALSE;

5 : bPIDmax2:=TRUE; rNod2:=20.5; bPIDmax1:=FALSE; bPIDmin2:= FALSE; bPIDmin1 :=FALSE;
6 : bPIDmax1:=TRUE; rNod1:=20.5; bPIDmin2:= FALSE; bPIDmin1 :=FALSE;
7 : bPIDmin1 :=TRUE; rNod1:=20.5; bPIDmax2:=FALSE; bPIDmax1:=FALSE;
8 : bPIDmin2:= TRUE; rNod2:=20.5; bPIDmax2:=FALSE; bPIDmax1:=FALSE;bPIDmin1 :=FALSE;
(*работа на одной горелки при аварии второй*)
9 : bPIDmax1:=TRUE; rNod1:= 41; bPIDmin1 :=FALSE;
10 : bPIDmin1:=TRUE; rNod1:= 41; bPIDmax1:=TRUE;
11 : bPIDmax2:=TRUE; rNod2:= 41; bPIDmin2 :=FALSE;
12 : bPIDmin2:=TRUE; rNod2:= 41; bPIDmax2:=TRUE;
13 : bPIDmax1:=FALSE; bPIDmax2:=FALSE; rNod1:=0; rNod2:=0; bPIDmin1:=TRUE; bPIDmin2:=TRUE;
END_CASE
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Switcher_FB
VAR_INPUT
	bStart1 : BOOL;
	bStart2 : BOOL;
	bError1 : BOOL;
	bError2: BOOL;
	bStart_out1_2 : BOOL;
END_VAR
VAR_OUTPUT
	bOut1 : BOOL;
	bOut2 : BOOL;
	bOutError1 : BOOL;
	bOutError2 : BOOL;
END_VAR
VAR
	Gen_Impuls1: Gen_Impuls;
	Gen_Impuls2: Gen_Impuls;
	bGen1Out1: BOOL;
	bGen1Out2: BOOL;
	bGen2Out1: BOOL;
	bGen2Out2: BOOL;
END_VAR
(*FB выполняет функцию переключения двух элементов, по заданому времени.
Также вывод элемента из цикла если пришла команда авария и запуск 
второго.
Запуск обоих элементов по сигналу*)

(* @END_DECLARATION := '0' *)
IF  bStart1  AND NOT bStart2
THEN Gen_Impuls1.enq := TRUE;
ELSE Gen_Impuls1.enq := FALSE;
END_IF

IF  bStart2 AND NOT bStart1
THEN Gen_Impuls2.enq := TRUE;
ELSE Gen_Impuls2.enq := FALSE;
END_IF

Gen_Impuls1( PTH:= t#12h, PTL:= t#12h);
(*Раздвоеие генератора и поочерёдное включение двух выходов*)
IF Gen_Impuls1.Q
THEN  bGen1Out2 := TRUE; (*переключение выходов*)
ELSE bGen1Out2 := FALSE;
END_IF
 	IF NOT Gen_Impuls1.Q
	THEN bGen1Out1  := TRUE; (*переключение выходов*)
	ELSE bGen1Out1 := FALSE;
	END_IF
		IF NOT Gen_Impuls1.enq
		THEN bGen1Out1 := FALSE; bGen1Out2 := FALSE;
		END_IF

Gen_Impuls2( PTH:= t#12h, PTL:= t#12h );

IF Gen_Impuls2.Q
THEN bGen2Out2 := TRUE; (*переключение выходов*)
ELSE bGen2Out2 := FALSE;
END_IF
 	IF NOT Gen_Impuls2.Q
	THEN bGen2Out1 := TRUE; (*переключение выходов*)
	ELSE bGen2Out1 := FALSE;
	END_IF
		IF NOT Gen_Impuls2.enq
		THEN bGen2Out1 := FALSE; bGen2Out2 := FALSE;
		END_IF

IF bGen1Out1  AND NOT bError1
	OR   bError2 AND bStart1
	OR bStart_out1_2
	OR bStart1 AND bStart2
	OR bGen2Out2 AND NOT bError1
	(*OR  NOT bError1 AND bStart2 AND bError2 *)
THEN bOut1 := TRUE;
ELSE bOut1 := FALSE;
END_IF

IF bGen1Out2 AND NOT bError2
	OR bError1 AND bStart2
	OR bStart_out1_2
	OR bStart1 AND bStart2
	OR bGen2Out1 AND NOT bError2
	(*OR  NOT bError2 AND bStart1 AND bError1 (*запуск второго элем.*)*)
THEN bOut2 := TRUE;
ELSE bOut2 := FALSE;
END_IF

IF bError1 AND bError2
	THEN bOut1 := FALSE; bOut2 := FALSE;
END_IF

(*отправить аварию дальше *)
IF bError1
THEN bOutError1 := TRUE;
ELSE bOutError1 := FALSE;
END_IF

IF  bError2
THEN bOutError2 := TRUE;
ELSE bOutError2 := FALSE;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ZadPower_FB
VAR_INPUT
	bStart : BOOL;
	bPIDmax : BOOL;
	bPIDmin : BOOL;
	t_min : REAL;
	t_poin_nod : REAL;
END_VAR
VAR_OUTPUT
	bOpen1 : BOOL;
	bClose1 : BOOL;
	rez_hod : REAL; (*значение мощности*)
	bStartBurner : BOOL;
END_VAR
VAR

	TON_Pod : TON;
	CTUD1 : CTUD;
	TP_open: TP;
	TP_close : TP;
END_VAR
(* @END_DECLARATION := '0' *)
TON_Pod(IN:= bStart, PT:= t#2s, Q=>, ET=> );
(*старт горелки *)
bStartBurner := SEL (bStart, FALSE, TRUE);
IF TON_Pod.Q
THEN
	TP_open(
		IN:= NOT TP_open.Q AND bPIDmax  AND (rez_hod<100),
		PT:=  REAL_TO_TIME (t_min*1000), Q=> , ET=> );
	TP_close(
		IN:= NOT TP_close.Q AND  bPIDmin  AND (rez_hod >= 0), (*как задавать NOT bPID кодта требуется мин *)
		PT:= REAL_TO_TIME (t_min*1000), Q=> , ET=> );
END_IF

	CTUD1.PV := REAL_TO_WORD(10*t_min *t_poin_nod);
	CTUD1(
		CU:= NOT TP_open.Q,
		CD:= NOT TP_close.Q,
		RESET:= ,
		LOAD:= ,
		PV:= ,
		QU=> ,
		QD=> ,
		CV=> );

rez_hod := (WORD_TO_REAL(CTUD1.CV-1)*t_min*100/t_poin_nod);

IF rez_hod>100
THEN rez_hod:= 100;
ELSIF rez_hod<0
THEN rez_hod:= 0;
END_IF
(*сброс счётчика  *)
IF   bStart
THEN CTUD1.RESET := FALSE;
ELSE CTUD1.RESET := TRUE;
END_IF
bOpen1 := SEL (TP_open.Q , FALSE, TRUE);
bClose1 := SEL (TP_close.Q, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION funUZ100_4_20mA : WORD (*Преобразование для ПЧ с диапазона 0..50 на 0..1000*)
VAR_INPUT
	Gerc : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
funUZ100_4_20mA := Gerc * 20;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION funUZ200_4_20mA : WORD (*Преобразование для ПЧ с диапазона 0..50 на 0..1000*)
VAR_INPUT
	Gerc : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
funUZ200_4_20mA := Gerc * 20;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION T_PLC_MS : DWORD
VAR_INPUT
	debug : BOOL := 0;
	N : INT := 0;
	offset : DWORD := 0;
END_VAR
VAR
	tx : TIME;
END_VAR
(*T_PLC_MS читает внутренними PLC таймер и вернуть время, он имеет преимущество, чтобы иметь возможность установить режим отладки
и ускорить счетчик для проверки ПЛК переполнения таймера, которое происходит раз в 50 дней, соответственно 25 дней на Сименс S7
эта процедура также позволяет корректировать поведение С7, где внутренний ПЛК счетчик не будет считать все 32 бита*)
(* @END_DECLARATION := '0' *)
tx := TIME();
T_PLC_MS := TIME_TO_DWORD(Tx);
(* здесь коррекция должна состояться step7
plctime нужно воспользоваться полного диапазона значений времени:
если у step7 time -24tage до плюс 24 дня должен то таймер при переполнении на -24tage прыгать 
и ни в коем случае на 0 !!!!
для siemens еще один ФБ должен быть включен в Майне представляет из себя учитываются все 32 бит через.
это только ФБ может быть он должен помнить, Верховный (32te) бит.
или около spring s7 при переполнении на -24 дней????? тогда без коррекции будет необходимо.
*)
IF debug THEN
	T_PLC_MS := (SHL(T_PLC_MS,N) OR SHL(DWORD#1,N)-1) + OFFSET;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PLC_PRG
VAR
	Block_normVoltage : Block_FB;
	invAlarm_Voltage: InvAlarm_FB;

	AlarmAND_BB1On :AlarmAND_FB;
	AlarmAND_BB2On :AlarmAND_FB;
	invAlarm_BO1Error: InvAlarm_FB;
	invAlarm_BO2Error: InvAlarm_FB;
	UZnoReady_BO1Got : UZnoReady_FB;
	UZnoReady_BO2Got : UZnoReady_FB;

	bEnebleTonHeating: BOOL;		(*Включить счётчик 300 сек на аварию эл обогревателя*)
	rTempCO: REAL;
	TonHeating: TON;
	Block_ElectricalHeating: Block_FB;
	bK3Off : BOOL; (*к3 не включился*)

	rTempCOValve: REAL;(*Включить счётчик 120 сек на аварию клапана обдува*)
	TonHeatingValve: TON;
	Block_ValveHeating: Block_FB;
	bErrValveHeating: BOOL;

	bErrVoltage: BOOL;
	bErrElectricalHeating: BOOL;
	bErrVoltageNormal: BOOL;
	bErrBO1: BOOL;
	bErrBO2: BOOL;
	bNotBO1Got: BOOL;
	bNotBO2Got: BOOL;
	bErrBB1On: BOOL;
	bErrBB2On: BOOL;
	ErrorBurner4: ErrorBurner_FB;
	ErrorBurner3: ErrorBurner_FB;
	ErrorBurner2: ErrorBurner_FB;
	ErrorBurner1: ErrorBurner_FB;
	bErrBurner1: BOOL;
	bErrBurner2: BOOL;
	bErrBurner3: BOOL;
	bErrBurner4: BOOL;
	bErrBurner1and2: BOOL;
	bErrBurner3and4: BOOL;
	tonPressHingGas: TON;
	bErrValveGas: BOOL;
	WarningGasPorog1: Warning_FB;
	bErrGasPorog1: BOOL;
	BlockGasPorog2: Block_FB;
	bErrGasPorog2: BOOL;
	InvAlarmFireBlokABGM: InvAlarm_FB;
	InvAlarmFireHangarGPA: InvAlarm_FB;
	bErrFireHangarGPA: BOOL;
	bErrFireBlokABGM: BOOL;
	BlockPressDropAirFilter: Block_FB;
	bErrPressDropAirFilter: BOOL;
	bErrBK101_tempTO1: BOOL;
	BlockErrBK101_tempTO1: Block_FB;
	BlockErrBK102_tempTO2: Block_FB;
	BlockErrBK202_tempTO4: Block_FB;
	BlockErrBK201_tempTO3: Block_FB;
	bErrBK201_tempTO3: BOOL;
	bErrBK102_tempTO2 : BOOL;
	bErrBK202_tempTO4: BOOL;
	BlockBK101_tempTO1: Block_FB;
	BlockErrValveGas : Block_FB;
	bErr350_tempTO1: BOOL;
	BlockBK102_tempTO2: Block_FB;
	bErr350_tempTO2: BOOL;
	bErr350_tempTO3: BOOL;
	bErr350_tempTO4: BOOL;
	BlockBK202_tempTO4: Block_FB;
	BlockBK201_tempTO3: Block_FB;
	WarningHighCH4Porog1: Warning_FB;
	bErrHighCH4Porog: BOOL;
	bErrHighCH4Porog2: BOOL;
	BlockHighCH4Porog2: Block_FB;
	WarningTempGas: Warning_FB;
	bErrTempGas: BOOL;
	BlockErrBK1_tempGas: Block_FB;
	bErrBK1_tempGas: BOOL;
	BlockErrBK2_tempAir: Block_FB;
	bErrBK2_tempAir: BOOL;
	WarningBK2_tempAir: Warning_FB;
	bErr60TempAir: BOOL;
	WarningBK2_tempAir70: Warning_FB;
	bErr70TempAir: BOOL;
	BlockBK2_tempAir80: Block_FB;
	bErr80tempAir: BOOL;
	BlockBK3_tempCO: Block_FB;
	bErrBK3_tempCO: BOOL;
	WarningBK3_tempCO10: Warning_FB;
	bErr10TempCO: BOOL;
	tonTempCO120 : TON;
	BlockTempCO120 : Block_FB;
	bErrTempCO120 : BOOL;
	WarningBK3_tempCO30: Warning_FB;
	bErr30TempCO: BOOL;
	BlockErrBP1_presAir: Block_FB;
	bErrBP1_presAir: BOOL;
	BlockErrBP2_presHing: Block_FB;
	bErrBP2_presHing: BOOL;
	BlockErrBP3_presLow: Block_FB;
	bErrBP3_presLow: BOOL;
	BlockBP101_PressDropTG1: Block_FB;
	bErrBP101_PressDropTG1: BOOL;
	BlockBP102_PressDropTG2: Block_FB;
	bErrBP102_PressDropTG2: BOOL;
	BlockBP201_PressDropTG3: Block_FB;
	bErrBP201_PressDropTG3: BOOL;
	BlockBP202_PressDropTG4: Block_FB;
	bErrBP202_PressDropTG4: BOOL;
	bErrPressDropTG1and2: BOOL;
	bErrPressDropTG3and4: BOOL;
	tonBP101_PressDropTG1 : TON;
	tonBP102_PressDropTG2 : TON;

	tonBP201_PressDropTG3 : TON;
	tonBP202_PressDropTG4 : TON;
	bErrBO1ob: BOOL; (*общая авария ВО не достигнута частота и авария*)
	bErrBO2ob: BOOL;
	BlockBP2PresLow : Block_FB;
	bErrBP2_Low : BOOL;
	BlockBP2PresHing : Block_FB;
	bErrBP2_Hing : BOOL;
	tonBP3PresLow : TON;
	BlockBP3PresLow : Block_FB;
	bErrBP3_Low : BOOL;
	BlockBP3PresHing : Block_FB;
	bErrBP3_Hing : BOOL;
	bErrObGasValve : BOOL;
	bErrLine1 : BOOL;
	bErrLine2 : BOOL;
	bErrObBurner1 : BOOL;
	bErrObBurner2 : BOOL;
	bErrObBurner3 : BOOL;
	bErrObBurner4 : BOOL;
	bErrObBO1 : BOOL;
	bErrObBO2 : BOOL;
	bErrBB1and2 : BOOL;

	Mode5_15_PID : Mode5_15 ;
	bBlink: BOOL  := TRUE;
	ptBB : TON;
	Switcher: Switcher_FB;
	Heating : Heating_FB;

	bButStart: BOOL;
	bStopPanel: BOOL;
	bStartSAYdisc : BOOL;
	bStopSAYdisc : BOOL;
	bStartSAYmod : BOOL;
	bStopSAYmod : BOOL;
	bStatrAVGM : BOOL;
	bFanMax : BOOL;

	byMode : BYTE; (*режимы*)
	FanObduva1 : FanObduva_FB;
	wRateBO1 : WORD :=35;
	FanObduva2 : FanObduva_FB;
	wRateBO2 : WORD  :=35;

	PIDburner1and2 : PID_PWM_CE;
	bObduv : BOOL;

	RS_Obduv : RS;
(*Настройка ПИД 1*)
	SwitcherBurner1 : Switcher_FB;
	SwBurner1and2 : SwBurner_FB;
	ZadPowerBuner1 : ZadPower_FB;
	ZadPowerBuner2 : ZadPower_FB;

(*Настройка ПИД 2*)
	PIDburner3and4 : PID_PWM_CE;
	SwitcherBurner3 : Switcher_FB;
	SwBurner3and4 : SwBurner_FB;
	ZadPowerBuner3 : ZadPower_FB;
	ZadPowerBuner4 : ZadPower_FB;

(*Наработка*)
	MotoHoursBurner1 : MotoHours_FB;
	MotoHoursBurner2 : MotoHours_FB;
	MotoHoursBurner3 : MotoHours_FB;
	MotoHoursBurner4 : MotoHours_FB;
	MotoHoursBO1 : MotoHours_FB;
	MotoHoursBO2 : MotoHours_FB;
	MotoHoursBB1 : MotoHours_FB;
	MotoHoursBB2 : MotoHours_FB;


	SAY_ModeSummer: BOOL;
	SAY_ModeHeadGPA: BOOL;

	SAY_FireHangarGPA: BOOL;
	SAY_FireBlokABGM: BOOL;
	SAY_HighCH4Porog1: BOOL;
	SAY_HighCH4Porog2: BOOL;
	SAY_StartBO1: BOOL;
	SAY_StartBO2: BOOL;
	SAY_StartBurner1: BOOL;
	SAY_StartBurner2: BOOL;
	SAY_StartBurner3: BOOL;
	SAY_StartBurner4: BOOL;
	ModeSummer: BOOL;
	ModeSummer2: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)

PLC_PRG.PLC_PRG.sayANDpanel();

IF b0x155  THEN  PLC_PRG.PLC_PRG.ModeManual(); b0x132:=TRUE; (*b0x155 кнопка перехода на панели*)

ELSE PLC_PRG.Alarm();
           PLC_PRG.ModeWork();
           PLC_PRG.Periphery();
 b0x132:=FALSE; (*индикатор ручного режима*)
END_IF

END_PROGRAM
ACTION	Alarm:
(*1*)(*Напряжения питания не в норме*);
Block_normVoltage(
	input:=NOT KU1_VoltageNormal,
	bError=> bErrVoltageNormal);

(*2*)(*Пропало основное напряжение питания*)
invAlarm_Voltage(
	inversion:= K2_OffVoltage,
	bError=> bErrVoltage);

(*3*)(*Неисправность электрообогрева секции обслуживания*)
bEnebleTonHeating := SEL (K5_EleHeatingEnable, FALSE, TRUE);

IF K5_EleHeatingEnable AND NOT K3_ElectricalHeating
THEN bK3Off := TRUE; bEnebleTonHeating := TRUE;
ELSE bK3Off := FALSE; bEnebleTonHeating := FALSE;
END_IF

IF bEnebleTonHeating     (*Включить счётчик 300 сек на аварию эл обогревателя*)
THEN
rTempCO :=  BK3_tempCO; (*запомнить*)
TonHeating.IN := TRUE;
bEnebleTonHeating := FALSE; (*сброс *)
ELSE TonHeating.IN := FALSE;
END_IF
(*за 300 сек темп не поднялась на 2 гр*)
IF TonHeating.Q AND (rTempCO + 2 > BK3_tempCO) OR bK3Off
THEN Block_ElectricalHeating.input := TRUE;
ELSE  Block_ElectricalHeating.input := FALSE;
END_IF

TonHeating(pt:= t#300s);

Block_ElectricalHeating(bError=> bErrElectricalHeating);

(*4*)(*Неисправность цепей вентилятора обдува 1 (М100)*)
invAlarm_BO1Error(
	inversion:= K102_BO1Error,
	bError=> bErrBO1);
(*Готовность*)
UZnoReady_BO1Got(
	bStart:= K103_BO1 AND NOT K24_CostsAirNormalHude,
	bRediness:= K101_BO1Got,
	bError=> bNotBO1Got);

IF bErrBO1 OR bNotBO1Got
THEN bErrBO1ob := TRUE;
ELSE bErrBO1ob := FALSE;
END_IF

(*5*)(*Неисправность цепей вентилятора обдува 2 (М200)*)
invAlarm_BO2Error(
	inversion:= K202_BO2Error,
	bError=> bErrBO2);
(*Готовность*)
UZnoReady_BO2Got(
	bStart:= K203_BO2On AND NOT K24_CostsAirNormalHude,
	bRediness:= K201_BO2Got ,
	bError=> bNotBO2Got);

IF bErrBO2 OR bNotBO2Got
THEN bErrBO2ob := TRUE;
ELSE bErrBO2ob := FALSE;
END_IF

(*6*)(*Неисправность вытяжного вентилятора 1*)
AlarmAND_BB1On(
	input:= K7_BB1On ,
	inversion:= K6_BB1On,
	bError=> bErrBB1On);

(*7*)(*Неисправность вытяжного вентилятора 2*)
AlarmAND_BB2On(
	input:= K22_BB2On,
	inversion:= K23_BB2On,
	bError=> bErrBB2On);

(*8*)(*Неисправность клапана отбора воздуха (М4)*)

IF K8_AirBlidVelvOpen     (*Включить счётчик 120 сек на аварию эл обогревателя*)
THEN
rTempCOValve :=  BK3_tempCO; (*запомнить*)
TonHeatingValve.IN := TRUE;
bEnebleTonHeating := FALSE; (*сброс *)
ELSE TonHeatingValve.IN := FALSE;
END_IF
(*за 120 сек темп не поднялась на 2 гр*)
IF TonHeatingValve.Q AND (rTempCO + 2 > BK3_tempCO)
THEN Block_ValveHeating.input := TRUE;
ELSE  Block_ValveHeating.input := FALSE;
END_IF

TonHeatingValve(pt:= t#120s);
Block_ValveHeating(bError=> bErrValveHeating);

(*9*)(*Неисправность горелки 1*)
ErrorBurner1(
	start:= K104_StartBurner1,
	lampWork:= K105_Burner1Work,
	lampAlarm:= K106_Burner1Error,
	error=>bErrBurner1 );

(*10*)(*Неисправность горелки 2*)
ErrorBurner2(
	start:= K109_StartBurner2,
	lampWork:= K110_Burner2Work,
	lampAlarm:= K111_Burner2Error,
	error=> bErrBurner2 );

(*11*)(*Неисправность горелок 1 и 2*)
IF bErrBurner1 AND bErrBurner2
THEN bErrBurner1and2 := TRUE;
ELSE bErrBurner1and2 := FALSE;
END_IF

(*12*)(*Неисправность горелки 3*)
ErrorBurner3(
	start:= K204_StartBurner3 ,
	lampWork:= K205_Burner3Work,
	lampAlarm:= K206_Burner3Error,
	error=> bErrBurner3 );

(*13*)(*Неисправность горелки 4*)
ErrorBurner4(
	start:= K209_StartBurner4,
	lampWork:= K210_Burner4Work,
	lampAlarm:= K211_Burner4Error ,
	error=> bErrBurner4);

(*14*)(*Неисправность горелок 3 и 4*)
IF bErrBurner3 AND bErrBurner4
THEN bErrBurner3and4 := TRUE;
ELSE bErrBurner3and4 := FALSE;
END_IF

(*15*)(*Неисправность отсечного газового клапана (М5)*)
IF K9_GasValveOpen AND BP2_presHing < 30
THEN tonPressHingGas.IN := TRUE;
ELSE tonPressHingGas.IN := FALSE;
END_IF

tonPressHingGas(PT := t#10s );


BlockErrValveGas(input:= tonPressHingGas.Q, bError=> bErrValveGas );

(*16*)(*Повышение оксида углерода в секции обслуживания порог 1*)
WarningGasPorog1(
	input:= K10_GasPorog1,
	bWarning=> bErrGasPorog1 );

(*17*)(*Повышение оксида углерода в секции обслуживания порог 2*)
BlockGasPorog2(
	input:= K11_GasPorog2 ,
	bError=> bErrGasPorog2 );

(*18*)(*Пожар в ангаре ГПА*)
InvAlarmFireHangarGPA(
	inversion:= K19_FireHangarGPA OR SAY_FireHangarGPA,
	bError=> bErrFireHangarGPA );

(*19*)(*Пожар в блоке АВГМ*)
InvAlarmFireBlokABGM(
	inversion:= K20_FireBlokABGM OR SAY_FireBlokABGM,
	bError=> bErrFireBlokABGM );

(*20*)(*Перепад давления на воздушном фильтре*)
BlockPressDropAirFilter(
	input:= K21_PressDropAirFilter ,
	bError=>bErrPressDropAirFilter );

(*21*)(*Неисправность датчика температуры теплообменника 1*)
BlockErrBK101_tempTO1 (
	input:= ErrBK101_tempTO1 >= 16#7,
	bError=> bErrBK101_tempTO1 );

(*22*)(*Неисправность датчика температуры теплообменника 2*)
BlockErrBK102_tempTO2 (
	input:= ErrBK102_tempTO2 >= 16#7,
	bError=> bErrBK102_tempTO2 );

(*23*)(*Неисправность датчика температуры теплообменника 3*)
BlockErrBK201_tempTO3 (
	input:= ErrBK201_tempTO3 >= 16#7,
	bError=> bErrBK201_tempTO3 );

(*24*)(*Неисправность датчика температуры теплообменника 4*)
BlockErrBK202_tempTO4 (
	input:= ErrBK202_tempTO4 >= 16#7,
	bError=> bErrBK202_tempTO4 );

(*25*)(*Перегрев теплообменника 1*)
BlockBK101_tempTO1 (
	input:= BK101_tempTO1 >= 350,
	bError=> bErr350_tempTO1 );

(*26*)(*Перегрев теплообменника 2*)
BlockBK102_tempTO2 (
	input:= BK102_tempTO2 >= 350,
	bError=> bErr350_tempTO2 );

(*27*)(*Перегрев теплообменника 3*)
BlockBK201_tempTO3 (
	input:= BK201_tempTO3 >= 350,
	bError=> bErr350_tempTO3 );

(*28*)(*Перегрев теплообменника 4*)
BlockBK202_tempTO4 (
	input:= BK202_tempTO4 >= 350,
	bError=> bErr350_tempTO4 );

(*29*)(*Загазованность по СН4 порог 1*)
WarningHighCH4Porog1(
	input:= K17_HighCH4Porog1 OR SAY_HighCH4Porog1,
	bWarning=> bErrHighCH4Porog );

(*30*)(*Загазованность по СН4 порог 2*)
BlockHighCH4Porog2(
	input:= K18_HighCH4Porog2 OR SAY_HighCH4Porog2,
	bError=> bErrHighCH4Porog2 );

(*31*)(*Неисправность датчика температуры газа*)
BlockErrBK1_tempGas(
	input:= ErrBK1_tempGas  >= 16#7,
	bError=> bErrBK1_tempGas);

(*32*)(*Температура газа не в норме*)
WarningTempGas(
	input:= BK1_tempGas < -5 OR  BK1_tempGas > 50,
	bWarning=> bErrTempGas );

(*33*)(*Неисправность датчика температуры воздуха на выходе АВГМ*)
BlockErrBK2_tempAir(
	input:= ErrBK2_tempAir  >= 16#7,
	bError=> bErrBK2_tempAir);

(*34*)(*Высокая температура на выходе теплогенератора 1 (ВК2)*)
WarningBK2_tempAir(
	input:= BK2_tempAir > 60,
	bWarning=> bErr60TempAir);

(*35*)(*Высокая температура на выходе теплогенератора 1 (ВК2)*)
WarningBK2_tempAir70(
	input:= BK2_tempAir > 70,
	bWarning=> bErr70TempAir);

(*36*)(*Аварийно высокая температура теплогенератора 1 (ВК2)*)
BlockBK2_tempAir80(
	input:= BK2_tempAir > 80,
	bError=> bErr80tempAir);

(*37*)(*Неисправность датчика температуры воздуха в секции обслуживания*)
BlockBK3_tempCO(
	input:= ErrBK3_tempCO  >= 16#7,
	bError=> bErrBK3_tempCO);

(*38*)(*Высокая температура воздуха в секции обслуживания*)
WarningBK3_tempCO30(
	input:= BK3_tempCO > 30,
	bWarning=> bErr30TempCO);

(*39*)(*Низкая температура воздуха в секции обслуживания*)
WarningBK3_tempCO10(
	input:= BK3_tempCO < 10,
	bWarning=> bErr10TempCO);

(*40*)(*Низкая температура воздуха в секции обслуживания во время работы АВГМ в течении 120 с.*)
IF bStatrAVGM AND bErr10TempCO
THEN tonTempCO120.IN := TRUE;
ELSE  tonTempCO120.IN := FALSE;
END_IF

tonTempCO120(PT:=t#120s );

BlockTempCO120(
	input:=tonTempCO120.Q ,
	bError=> bErrTempCO120 );

(*41*)(*Неисправность датчика давления воздуха в воздуховоде (ВР1)*)
BlockErrBP1_presAir(
	input:= ErrBP1_presAir  >= 16#7,
	bError=> bErrBP1_presAir);

(*42*)(*Неисправность датчика давления газа до регулятора (ВР2)*)
BlockErrBP2_presHing(
	input:= ErrBP2_presHing  >= 16#7,
	bError=> bErrBP2_presHing);

(*43*)(*Низкое давление газа до регулятора*)
IF b0x141 AND (BP2_presHing <= 20)
OR b0x142 AND (BP2_presHing <=20)
OR b0x144 AND (BP2_presHing <= 20)
OR b0x146 AND (BP2_presHing <= 20)
THEN BlockBP2PresLow.input := TRUE;
ELSE  BlockBP2PresLow.input := FALSE;
END_IF
BlockBP2PresLow(bError=> bErrBP2_Low);

(*44*)(*Высокое давление газа до регулятора*)
IF  BP2_presHing >=520
THEN BlockBP2PresLow.input := TRUE;
ELSE  BlockBP2PresLow.input := FALSE;
END_IF
BlockBP2PresHing(bError=> bErrBP2_Hing);

(*45*)(*Неисправность датчика давления газа до регулятора (ВР3)*)
BlockErrBP3_presLow(
	input:= ErrBP3_presLow  >= 16#7,
	bError=> bErrBP3_presLow);

(*46*)(*Низкое давление газа после регулятора *)
IF b0x141 AND (BP3_presLow < 5)
OR b0x142 AND (BP3_presLow < 5)
OR b0x144 AND (BP3_presLow < 5)
OR b0x146 AND (BP3_presLow < 5)
THEN tonBP3PresLow.IN := TRUE;
ELSE  tonBP3PresLow.IN := FALSE;
END_IF
tonBP3PresLow(PT:=t#30s);
BlockBP3PresLow(
	input:=tonBP3PresLow.Q ,
	bError=> bErrBP3_Low);

(*47*)(*Высокое давление газа после регулятора*)
IF b0x141 AND (BP3_presLow >= 25)
OR b0x142 AND (BP3_presLow >= 25)
OR b0x144 AND (BP3_presLow >= 25)
OR b0x146 AND (BP3_presLow >= 25)
THEN BlockBP3PresHing.input := TRUE;
ELSE  BlockBP3PresHing.input := FALSE;
END_IF
BlockBP3PresHing(bError=> bErrBP3_Hing);

(*48*)(*Перепад давления теплообменника 1*)
tonBP101_PressDropTG1 (in:= , PT:= T#30s);

IF K105_Burner1Work  AND K103_BO1  AND BP101_PressDropTG1 AND NOT K24_CostsAirNormalHude
THEN   tonBP101_PressDropTG1.IN:= TRUE;
ELSE  tonBP101_PressDropTG1.IN := FALSE;
END_IF

BlockBP101_PressDropTG1(input:= tonBP101_PressDropTG1.Q );

IF BlockBP101_PressDropTG1.bError
THEN bErrBP101_PressDropTG1 := TRUE;
ELSE bErrBP101_PressDropTG1 := FALSE;
END_IF

(*49*)(*Перепад давления теплообменника 2*)
tonBP102_PressDropTG2 (in:= , PT:= T#30s);

IF K110_Burner2Work  AND K103_BO1  AND BP102_PressDropTG2 AND NOT K24_CostsAirNormalHude
THEN   tonBP102_PressDropTG2.IN:= TRUE;
ELSE  tonBP102_PressDropTG2.IN := FALSE;
END_IF

BlockBP102_PressDropTG2(input:= tonBP102_PressDropTG2.Q );

IF BlockBP102_PressDropTG2.bError
THEN bErrBP102_PressDropTG2 := TRUE;
ELSE bErrBP102_PressDropTG2 := FALSE;
END_IF

(*50*)(*Перепад давления теплообменников 1 и 2*)
IF bErrBP101_PressDropTG1 AND bErrBP102_PressDropTG2
THEN bErrPressDropTG1and2 := TRUE;
ELSE bErrPressDropTG1and2 := FALSE;
END_IF

(*51*)(*Перепад давления теплообменника 3*)

tonBP201_PressDropTG3(in:= , PT:= T#30s);

IF K205_Burner3Work AND K203_BO2On  AND  BP201_PressDropTG3 AND NOT K24_CostsAirNormalHude
THEN   tonBP201_PressDropTG3.IN:= TRUE;
ELSE  tonBP201_PressDropTG3.IN := FALSE;
END_IF

BlockBP201_PressDropTG3(input:= tonBP201_PressDropTG3.Q );

IF BlockBP201_PressDropTG3.bError
THEN bErrBP201_PressDropTG3 := TRUE;
ELSE bErrBP201_PressDropTG3 := FALSE;
END_IF

(*52*)(*Перепад давления теплообменника 4*)
tonBP202_PressDropTG4(in:= , PT:= T#30s);

IF K210_Burner4Work AND K203_BO2On  AND BP202_PressDropTG4 AND NOT K24_CostsAirNormalHude
THEN   tonBP202_PressDropTG4.IN:= TRUE;
ELSE  tonBP202_PressDropTG4.IN := FALSE;
END_IF

BlockBP202_PressDropTG4(input:= tonBP202_PressDropTG4.Q );

IF BlockBP202_PressDropTG4.bError
THEN bErrBP202_PressDropTG4 := TRUE;
ELSE bErrBP202_PressDropTG4 := FALSE;
END_IF

(*53*)(*Перепад давления теплообменников 3 и 4*)
IF bErrBP201_PressDropTG3 AND bErrBP202_PressDropTG4
THEN bErrPressDropTG3and4 := TRUE;
ELSE bErrPressDropTG3and4 := FALSE;
END_IF

PLC_PRG.AlarmOb;











END_ACTION

ACTION	AlarmOb:

(*Общие авария отключение питания*)
IF bErrVoltageNormal
OR bErrVoltage
OR bErrHighCH4Porog2
OR NOT  SB1_PressKeyErrorStop
OR bErrFireHangarGPA
OR bErrFireBlokABGM
THEN K1_AlarmOffVoltage:= TRUE;
ELSE K1_AlarmOffVoltage:= FALSE;
END_IF
(*неистравность двух ВВ и останов агрегата*)
IF bErrBB1On AND bErrBB2On
THEN bErrBB1and2 := TRUE;
ELSE bErrBB1and2 := FALSE;
END_IF

(*общии аварии для режима обогрев линия 1*)
IF bNotBO1Got
OR bErrBurner1and2
OR bErrBK101_tempTO1 AND bErrBK102_tempTO2
OR bErr350_tempTO1
OR bErr350_tempTO2
OR bErrBK1_tempGas
OR bErrBK2_tempAir
OR bErr80tempAir
OR bErrBP2_Low
OR bErrBP2_Hing
OR bErrBP3_presLow
OR bErrBP3_Low
OR bErrBP3_Hing
OR bErrPressDropTG1and2
OR K1_AlarmOffVoltage (*не только отключит но и заблокирует*)
OR bErrBB1and2 (*Если неисправны оба ВВ то останов*)
OR bErrTempGas
OR bErrObGasValve
OR bErrBK3_tempCO
THEN bErrLine1 := TRUE;
ELSE bErrLine1 := FALSE;
END_IF

(*общии аварии для режима обогрев линия 2*)
IF bNotBO1Got
OR bErrBurner3and4
OR bErrBK201_tempTO3 AND bErrBK202_tempTO4
OR bErr350_tempTO3
OR bErr350_tempTO4
OR bErrBK1_tempGas
OR bErrBK2_tempAir
OR bErr80tempAir
OR bErrBP2_Low
OR bErrBP2_Hing
OR bErrBP3_presLow
OR bErrBP3_Low
OR bErrBP3_Hing
OR bErrPressDropTG3and4
OR K1_AlarmOffVoltage (*не только отключит но и заблокирует*)
OR bErrBB1and2 (*Если неисправны оба ВВ то останов*)
OR bErrTempGas
OR bErrObGasValve
OR bErrBK3_tempCO
THEN bErrLine2 := TRUE;
ELSE bErrLine2 := FALSE;
END_IF

(*общая авария горелки 1*)
IF bErrBP101_PressDropTG1 OR bErrBurner1 OR bErrBK101_tempTO1
THEN bErrObBurner1 := TRUE;
ELSE  bErrObBurner1 := FALSE;
END_IF
(*общая авария горелки 2*)
IF bErrBP102_PressDropTG2 OR bErrBurner2 OR bErrBK102_tempTO2
THEN bErrObBurner2 := TRUE;
ELSE  bErrObBurner2 := FALSE;
END_IF

(*общая авария горелки 3*)
IF bErrBP201_PressDropTG3 OR bErrBurner3 OR bErrBK201_tempTO3
THEN bErrObBurner3 := TRUE;
ELSE  bErrObBurner3 := FALSE;
END_IF

(*общая авария горелки 4*)
IF bErrBP202_PressDropTG4 OR bErrBurner4 OR  bErrBK202_tempTO4
THEN bErrObBurner4 := TRUE;
ELSE  bErrObBurner4 := FALSE;
END_IF

(*общая авария ВО1*)
IF K1_AlarmOffVoltage
OR bErrBP1_presAir
OR  bErrPressDropAirFilter
OR (BP1_presAir > 800)
OR bErrBO1ob
THEN bErrObBO1 := TRUE;
ELSE bErrObBO1 := FALSE;
END_IF

(*общая авария ВО2*)
IF K1_AlarmOffVoltage
OR bErrBP1_presAir
OR  bErrPressDropAirFilter
OR (BP1_presAir > 800)
OR bErrBO1ob
THEN bErrObBO1 := TRUE;
ELSE bErrObBO2 := FALSE;
END_IF

(*сигнализации о аварии*)
IF bErrVoltageNormal OR bErrVoltage OR bErrElectricalHeating
OR bErrBO1ob OR bErrBO2ob OR bErrBB1On OR bErrBB2On
OR bErrBurner1 OR bErrBurner2 OR bErrBurner3 OR bErrBurner4
OR bErrValveGas OR bErrGasPorog2 OR bErrFireHangarGPA
OR bErrFireBlokABGM OR bErrPressDropAirFilter
OR bErrBK101_tempTO1 OR bErrBK102_tempTO2
OR bErrBK201_tempTO3 OR bErrBK202_tempTO4
OR bErr350_tempTO1 OR bErr350_tempTO2
OR bErr350_tempTO3 OR bErr350_tempTO4
 OR bErrHighCH4Porog2
OR bErrBK1_tempGas OR bErrTempGas
OR bErrBK2_tempAir OR bErr60TempAir OR bErr70TempAir
OR bErr80tempAir OR bErrBK3_tempCO OR bErr30TempCO
OR bErr10TempCO OR bErrBP1_presAir OR bErrBP2_presHing
OR bErrBP2_Low OR bErrBP2_Hing OR bErrBP3_presLow
OR bErrBP3_Low OR bErrBP3_Hing OR bErrBP101_PressDropTG1
OR bErrBP102_PressDropTG2 OR bErrBP201_PressDropTG3
OR bErrBP202_PressDropTG4
THEN K16_ABGMError := FALSE ;
ELSE K16_ABGMError := TRUE ;
END_IF

(*аварии ОГК*)
IF K1_AlarmOffVoltage
OR bErrBurner1and2 AND bErrBurner3and4 (*неисп. все горелки*)
OR bErrValveGas
OR bErrBP2_presHing
OR bErrBP2_Hing
OR bErrBP2_Low
OR bErrTempGas
OR bErrBK1_tempGas
THEN bErrObGasValve := TRUE;
ELSE bErrObGasValve := FALSE;
END_IF
END_ACTION

ACTION	ModeManual:
(*Выхода*)

K1_AlarmOffVoltage 		    := SEL (b0x91, FALSE, TRUE);
K5_EleHeatingEnable 		    := SEL (b0x88, FALSE, TRUE);
K4_EleHeatingOff 			    := SEL (b0x92, FALSE, TRUE);
K103_BO1 					    := SEL (b0x60, FALSE, TRUE);
K203_BO2On 				    := SEL (b0x61, FALSE, TRUE);
K7_BB1On 	     			    := SEL (b0x89, FALSE, TRUE);
K8_AirBlidVelvOpen		    := SEL (b0x90, FALSE, TRUE);
K104_StartBurner1 		           := SEL (b0x56, FALSE, TRUE);
K109_StartBurner2			    := SEL (b0x57, FALSE, TRUE);
K204_StartBurner3 			    := SEL (b0x58, FALSE, TRUE);
K209_StartBurner4			    := SEL (b0x59, FALSE, TRUE);
K107_minPowerBurner1	    := SEL (b0x62, FALSE, TRUE);
K108_maxPowerBurner1	     := SEL (b0x66, FALSE, TRUE);
K112_minPowerBurner2   	     := SEL (b0x63, FALSE, TRUE);
K113_maxPowerBurner2	     := SEL (b0x67, FALSE, TRUE);
K207_minPowerBurner3	     := SEL (b0x64, FALSE, TRUE);
K208_maxPowerBurner3 	     := SEL (b0x68, FALSE, TRUE);
K212_minPowerBurner4	     := SEL (b0x65, FALSE, TRUE);
K213_maxPowerBurner4	     := SEL (b0x69, FALSE, TRUE);
K9_GasValveOpen			    := SEL (b0x87, FALSE, TRUE);
K15_ABGMWork 			    := SEL (b0x94, FALSE, TRUE);
K16_ABGMError 			    := SEL (b0x95, FALSE, TRUE);
K22_BB2On 				    := SEL (b0x93, FALSE, TRUE);
K25_OnHeadDrainCondensat := SEL (b0x96, FALSE, TRUE);
(*Входа*)
b0x97 := SEL (SB4_ButStart, FALSE, TRUE);
b0x98 := SEL (SA1_WorkStop, FALSE, TRUE);
b0x99 := SEL (K2_OffVoltage, FALSE, TRUE);
b0x100 := SEL (K3_ElectricalHeating, FALSE, TRUE);
b0x85 := SEL ( K101_BO1Got, FALSE, TRUE);
b0x79 := SEL (NOT K102_BO1Error, FALSE, TRUE);
b0x86 := SEL (K201_BO2Got, FALSE, TRUE);
b0x80 := SEL (NOT K202_BO2Error, FALSE, TRUE);
b0x101 := SEL (K6_BB1On, FALSE, TRUE);
b0x81 := SEL (K105_Burner1Work, FALSE, TRUE);
b0x75 := SEL (K106_Burner1Error, FALSE, TRUE);
b0x82 := SEL (K110_Burner2Work, FALSE, TRUE);
b0x76 := SEL (K111_Burner2Error, FALSE, TRUE);
b0x83 := SEL (K205_Burner3Work, FALSE, TRUE);
b0x77 := SEL (K206_Burner3Error, FALSE, TRUE);
b0x84 := SEL (K210_Burner4Work, FALSE, TRUE);
b0x78 := SEL (K211_Burner4Error, FALSE, TRUE);
b0x102 := SEL (K10_GasPorog1, FALSE, TRUE);
b0x103 := SEL (K11_GasPorog2, FALSE, TRUE);
b0x104 := SEL (K12_StartABGM, FALSE, TRUE);
b0x105 := SEL (K13_ModeSummer, FALSE, TRUE);
b0x106 := SEL (K14_ModeHeadGPA, FALSE, TRUE);
b0x107 := SEL (K17_HighCH4Porog1, FALSE, TRUE);
b0x108 := SEL (K18_HighCH4Porog2, FALSE, TRUE);
b0x109 := SEL (K19_FireHangarGPA, FALSE, TRUE);
b0x110 := SEL (K20_FireBlokABGM, FALSE, TRUE);
b0x111 := SEL (K21_PressDropAirFilter, FALSE, TRUE);
b0x112 := SEL (KU1_VoltageNormal, FALSE, TRUE);
b0x113 := SEL (SB1_PressKeyErrorStop, FALSE, TRUE);
b0x114 := SEL (K23_BB2On, FALSE, TRUE);
b0x74 := SEL (K24_CostsAirNormalHude, FALSE, TRUE);
b0x70 := SEL (BP101_PressDropTG1, FALSE, TRUE);
b0x71 := SEL (BP102_PressDropTG2, FALSE, TRUE);
b0x72 := SEL (BP201_PressDropTG3, FALSE, TRUE);
b0x73 := SEL (BP202_PressDropTG4, FALSE, TRUE);

(*Задание частоты*)


(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(35);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(35);
END_IF
END_ACTION

ACTION	ModeWork:
(*Блокировка режимов*)
IF b0x136 AND b0x141
OR b0x136 AND b0x142
OR b0x136 AND b0x144
OR b0x136 AND b0x146
OR b0x139 AND b0x141
OR b0x139 AND b0x142
OR b0x139 AND b0x144
OR b0x139 AND b0x146
OR b0x136 AND b0x139
OR b0x141 AND b0x144
OR b0x141 AND b0x146
OR b0x142 AND b0x144
OR b0x142 AND b0x146
THEN b0x136 := FALSE; b0x139 := FALSE; b0x141 := FALSE; b0x144 := FALSE; b0x142 := FALSE;  b0x146 := FALSE;   b0x54 := TRUE;
ELSE b0x54 := FALSE; byMode := 0;
END_IF

(*серая кнопка*)
IF b0x136  AND bStatrAVGM (*b0x136 вент обд 1*)
OR b0x139 AND bStatrAVGM (*b0x139 вент обд 2*)
OR b0x141 AND bStatrAVGM (*b0x141 гор 1*)
OR b0x144  AND bStatrAVGM (*b0x144 гор 3*)
OR b0x142 AND bStatrAVGM (*b0x142 гор 2*)
OR b0x146 AND bStatrAVGM (*b0x146 гор 4*)
THEN b0x138 := TRUE;
ELSE b0x138 := FALSE ;
END_IF

(*режим лето*)
IF K13_ModeSummer AND NOT bErrObBO1 OR SAY_ModeSummer AND NOT bErrObBO1 (*запустить от режима лето, *)
THEN ModeSummer :=TRUE; b0x116 := TRUE;
ELSIF bErrObBO1 AND NOT bErrObBO2 (*запустить от режима лето, если неисправен ВО1 *)
THEN ModeSummer2 :=TRUE; b0x116 := TRUE;
ELSE ModeSummer := FALSE; ModeSummer2 :=FALSE; b0x116 := FALSE;
END_IF

(*Пуск в режимов*)
IF bStatrAVGM AND NOT bErr10TempCO
THEN
	IF b0x136 AND NOT bErrObBO1 OR ModeSummer OR SAY_StartBO1 AND NOT bErrObBO1(*BO 1*)
	THEN byMode := 1;
	END_IF
	IF b0x139 AND NOT bErrObBO2 OR ModeSummer2 OR SAY_StartBO2 AND NOT bErrObBO2 (*BO 2*)
	THEN byMode := 2;
	END_IF

		IF b0x141 AND NOT bErrLine1 OR SAY_StartBurner1 AND NOT bErrLine1 (*гор 1*)
		THEN byMode := 3;
		END_IF
		IF b0x142   AND NOT bErrLine1 OR SAY_StartBurner2 AND NOT bErrLine1(*гор  2*)
		THEN byMode := 4;
		END_IF
		IF b0x141  AND b0x142   AND NOT bErrLine1 (*гор 1and2*)
		THEN byMode := 5;
		END_IF

			IF b0x144 AND NOT bErrLine2 OR SAY_StartBurner3 AND NOT bErrLine2 (*гор  3*)
			THEN byMode := 6;
			END_IF
			IF b0x146 AND NOT bErrLine2 OR SAY_StartBurner4 AND NOT bErrLine2 (*гор  4*)
			THEN byMode := 7;
			END_IF
			IF b0x144 AND b0x146 AND NOT bErrLine2 (*гор 3and4*)
			THEN byMode := 8;
			END_IF
ELSE byMode := 0;
END_IF

(*пуск горело 1 и 2 *)
IF byMode = 3
THEN SwitcherBurner1.bStart1 := TRUE;
ELSE SwitcherBurner1.bStart1 := FALSE;
END_IF

IF byMode = 4
THEN SwitcherBurner1.bStart2 := TRUE;
ELSE SwitcherBurner1.bStart2 := FALSE;
END_IF

IF byMode = 5
THEN SwitcherBurner1.bStart_out1_2 := TRUE;
ELSE SwitcherBurner1.bStart_out1_2 := FALSE;
END_IF

(*запуск ПИД если выбран один из режимов обогрева 1 линии*)
IF byMode = 3 OR byMode = 4 OR byMode = 5
THEN PIDburner1and2.AVT_REG := TRUE;
ELSE PIDburner1and2.AVT_REG := FALSE;
END_IF

SwitcherBurner1(
	bError1 := bErrObBurner1 ,
	bError2 := bErrObBurner2 );

PIDburner1and2(
	ACTUAL:= Mode5_15_PID.wYstavkaPID_FB,
	SET_POINT:= Mode5_15_PID.wZadaniePID_FB,
	KP:= wPID1prop ,
	TN:= wPID1intg,
	TV:=  wPID1diff,
	D_ZONE:= ,
	kn_RUCH_Y_UP:= ,
	kn_RUCH_Y_DOWN:= , 
	Time_PWM:= 500  );

SwBurner1and2(
	bInput1:= SwitcherBurner1.bOut1,
	bInput2:= SwitcherBurner1.bOut2,
	rZad1:= ZadPowerBuner1.rez_hod,
	rZad2:= ZadPowerBuner2.rez_hod,
	Y_UP:= PIDburner1and2.Y_UP,
	Y_DOWN:= PIDburner1and2.Y_DOWN ,
	bInError1 :=  SwitcherBurner1.bOutError1,
	bInError2 := SwitcherBurner1.bOutError2,
	rTempTO1 :=  BK101_tempTO1,
	rTempTO2 := BK102_tempTO2);

ZadPowerBuner1(
	bStart:= SwBurner1and2.bStartPower1,
	bPIDmax:= SwBurner1and2.bPIDmax1,
	bPIDmin:= SwBurner1and2.bPIDmin1,
	t_min:= 1, (*проверить *)
	t_poin_nod:= SwBurner1and2.rNod1,
	bOpen1=> K108_maxPowerBurner1,
	bClose1=> K107_minPowerBurner1,
	bStartBurner => K104_StartBurner1);

ZadPowerBuner2(
	bStart:= SwBurner1and2.bStartPower2,
	bPIDmax:= SwBurner1and2.bPIDmax2,
	bPIDmin:= SwBurner1and2.bPIDmin2,
	t_min:= 1,
	t_poin_nod:= SwBurner1and2.rNod2,
	bOpen1=> K113_maxPowerBurner2,
	bClose1=> K112_minPowerBurner2 ,
	bStartBurner => K109_StartBurner2);


(*запуск ВО1*)

IF byMode =1 AND NOT bErrBO1ob
OR K104_StartBurner1 AND (BK101_tempTO1>40) AND NOT bErrBO1ob
OR K109_StartBurner2 AND (BK102_tempTO2>40) AND NOT bErrBO1ob
OR RS_Obduv.Q1 AND b0x141  AND NOT bErrBO1ob
OR RS_Obduv.Q1  AND b0x142 AND NOT bErrBO1ob  (*переключатель обдува*)
THEN FanObduva1.bRun := TRUE;
ELSE FanObduva1.bRun := FALSE;
END_IF
(*изменение частоты и запуск*)
FanObduva1(
	bModeMax:= bFanMax,
	bOutStart=> K103_BO1,
	wRate=> wRateBO1 );



(*пуск горело 3 и 4 *)
IF byMode = 6
THEN SwitcherBurner3.bStart1 := TRUE;
ELSE SwitcherBurner3.bStart1 := FALSE;
END_IF

IF byMode = 7
THEN SwitcherBurner3.bStart2 := TRUE;
ELSE SwitcherBurner3.bStart2 := FALSE;
END_IF

IF byMode = 8
THEN SwitcherBurner3.bStart_out1_2 := TRUE;
ELSE SwitcherBurner3.bStart_out1_2 := FALSE;
END_IF

(*запуск ПИД если выбран один из режимов обогрева 1 линии*)
IF byMode >=6
THEN PIDburner3and4.AVT_REG := TRUE;
ELSE PIDburner3and4.AVT_REG := FALSE;
END_IF

SwitcherBurner3(
	bError1 := bErrObBurner3 ,
	bError2 := bErrObBurner4 );

PIDburner3and4(
	ACTUAL:= Mode5_15_PID.wYstavkaPID_FB,
	SET_POINT:= Mode5_15_PID.wZadaniePID_FB,
	KP:= wPID2prop,
	TN:= wPID2intg,
	TV:=  wPID2diff,
	D_ZONE:= ,
	kn_RUCH_Y_UP:= ,
	kn_RUCH_Y_DOWN:= ,
	Time_PWM:= 500  );

SwBurner3and4(
	bInput1:= SwitcherBurner3.bOut1,
	bInput2:= SwitcherBurner3.bOut2,
	rZad1:= ZadPowerBuner3.rez_hod,
	rZad2:= ZadPowerBuner4.rez_hod,
	Y_UP:= PIDburner3and4.Y_UP,
	Y_DOWN:= PIDburner3and4.Y_DOWN ,
	bInError1 :=  SwitcherBurner3.bOutError1,
	bInError2 := SwitcherBurner3.bOutError2,
	rTempTO1 :=  BK201_tempTO3,
	rTempTO2 := BK202_tempTO4);

ZadPowerBuner3(
	bStart:= SwBurner3and4.bStartPower1,
	bPIDmax:= SwBurner3and4.bPIDmax1,
	bPIDmin:= SwBurner3and4.bPIDmin1,
	t_min:= 1, (*проверить *)
	t_poin_nod:= SwBurner3and4.rNod1,
	bOpen1=>  K208_maxPowerBurner3,
	bClose1=> K207_minPowerBurner3,
	bStartBurner => K204_StartBurner3);

ZadPowerBuner4(
	bStart:= SwBurner3and4.bStartPower2,
	bPIDmax:= SwBurner3and4.bPIDmax2,
	bPIDmin:= SwBurner3and4.bPIDmin2,
	t_min:= 1,
	t_poin_nod:= SwBurner3and4.rNod2,
	bOpen1=> K213_maxPowerBurner4,
	bClose1=> K212_minPowerBurner4 ,
	bStartBurner => K209_StartBurner4);


(*запуск ВО2*)
IF byMode =2 AND NOT bErrBO2ob
OR K204_StartBurner3 AND (BK201_tempTO3>40) AND NOT bErrBO2ob
OR K209_StartBurner4 AND (BK202_tempTO4>40) AND NOT bErrBO2ob
OR RS_Obduv.Q1 AND b0x144  AND NOT bErrBO2ob
OR RS_Obduv.Q1  AND b0x146 AND NOT bErrBO2ob  (*переключатель обдува*)
THEN FanObduva2.bRun := TRUE;
ELSE FanObduva2.bRun := FALSE;
END_IF

FanObduva2(
	bRun:= ,
	bModeMax:= bFanMax,
	bOutStart=> K203_BO2On ,
	wRate=> wRateBO2 );



(*обдув*)
IF K104_StartBurner1 OR K109_StartBurner2 OR K204_StartBurner3 OR K209_StartBurner4
THEN bObduv :=TRUE; (*включет переключатель RS*)
ELSE bObduv :=FALSE;
END_IF

IF BK101_tempTO1<40 AND  BK102_tempTO2<40 AND BK201_tempTO3<40 AND BK202_tempTO4<40
THEN  RS_Obduv.RESET1:= TRUE; (*будет держать переключатель выключенным пака тамп не опустится*)
ELSE RS_Obduv.RESET1 := FALSE;
END_IF
RS_Obduv(SET:= bObduv );

(*подача сигнала нормальный останов*)
IF (BK101_tempTO1>40) AND  NOT bObduv
OR (BK102_tempTO2>40) AND  NOT bObduv
OR (BK201_tempTO3>40) AND  NOT bObduv
OR (BK202_tempTO4>40) AND  NOT bObduv
THEN b0x119 := TRUE;
ELSE b0x119 := FALSE;
END_IF

END_ACTION

ACTION	Periphery:
(*запус АВГМ*)
IF SA1_WorkStop
THEN
	IF SB4_ButStart (*алгоритв вкл от кнопки на ШУ*)
	THEN bButStart := TRUE;
			b0x115 := TRUE; (*отображение кнопки стоп на панели*)
	END_IF
		IF  b0x153 (*кнопка стоп на панели*)
		THEN bStopPanel := TRUE; bButStart:= FALSE;
		ELSE bStopPanel := FALSE;
		END_IF
		IF b0x153 (*выключить подсветку кнопки и сбросить кнопку стоп*)
		THEN b0x115 := FALSE; b0x153 := FALSE;
		END_IF

			IF K12_StartABGM (*алгоритм вкл от САУ дискретом*)
			THEN bStartSAYdisc := TRUE;
			END_IF
				IF bStartSAYdisc AND NOT K12_StartABGM
				THEN bStopSAYdisc := TRUE; bStartSAYdisc:= FALSE;
				ELSE bStopSAYdisc := FALSE;
				END_IF
			IF bInReg12_0 (*алгоритм вкл от САУ Модбас*)
			THEN   bStartSAYmod:= TRUE;
			END_IF
				IF bStartSAYmod AND NOT bInReg12_0
				THEN bStopSAYmod := TRUE; bStartSAYmod:= FALSE;
				ELSE bStopSAYmod := FALSE;
				END_IF
(*сброс всего натыконого, при переводе переключателя в останов*)
ELSE bStopPanel := TRUE; bStopSAYdisc := TRUE; bStopSAYmod := TRUE;
	    bButStart:= FALSE; bStartSAYdisc := FALSE; bStartSAYmod := FALSE;
END_IF

	IF bButStart OR bStartSAYdisc OR bStartSAYmod
	THEN bStatrAVGM := TRUE; K15_ABGMWork := TRUE;
	ELSIF bStopPanel OR bStopSAYdisc OR bStopSAYmod
	THEN bStatrAVGM := FALSE; K15_ABGMWork := FALSE;
	END_IF

(*сборка на запуск макcимального режима*)
IF K24_CostsAirNormalHude OR bInReg12_3
THEN bFanMax := TRUE;
ELSE bFanMax := FALSE;
END_IF

(*вентиляторы обдува*)
(*за переключение отвечает Switcher.*
а Конструкция ниже отвечает за первоначальный запуск ВВ1 и дальнейшее переключение*)
IF   bBlink AND NOT b0x134
OR  ptBB.Q AND NOT b0x135
OR b0x134 AND b0x135
THEN Switcher.bStart1 := TRUE;
ELSE Switcher.bStart1 := FALSE;
END_IF
IF b0x134 OR  b0x135
THEN bBlink:= FALSE; ptBB.IN := TRUE;
ELSIF NOT b0x134
THEN ptBB.IN := FALSE;  bBlink:= TRUE;
END_IF

ptBB(PT:= t#500ms ); (*Задержка времена т.к. bStart1 не успевает перезапустится *)

Switcher(
	bStart2:= b0x135  ,
	bError1:= bErrBB1On ,
	bError2:= bErrBB2On,
	bStart_out1_2:= ,
	bOut1=> K7_BB1On,
	bOut2=> K22_BB2On);

IF bErrGasPorog1 OR bErrHighCH4Porog OR bErr30TempCO
THEN Switcher.bStart_out1_2 := TRUE;
ELSE Switcher.bStart_out1_2 := FALSE;
END_IF

(*задание температурных режимов*)


Mode5_15_PID(
	bSignalSAY:= ,
	bSignalDiscret:= K14_ModeHeadGPA OR SAY_ModeHeadGPA,
	bWork1:= b0x150 ,
	bWork2:=  b0x151,
	reTempRoom:= TempRoom,
	reTempExit:= BK2_tempAir,
	wPanelZad1:= r4x35,
	wPanelZad2:= r4x36,
	bPanelTableZad=> b0x149 ,
	bPanelTable5_15=>  b0x148,
	wZadaniePID_FB=> ,
	wYstavkaPID_FB=> );

(*обогрев*)

Heating(
	byMode_FB:= , 
	wTempCO:= BK3_tempCO ,
	wYstPanel:= r4x26,
	bErrorHeating:= ,
	bErrorVolveAir:= ,
	bHeatingEneble=>K5_EleHeatingEnable ,
	bHeatingOff=> K4_EleHeatingOff,
	bVolveAirEneble=> K8_AirBlidVelvOpen);

(*газовый клапан*)
IF NOT bErrObGasValve AND b0x141
OR NOT bErrObGasValve AND b0x142
OR NOT bErrObGasValve AND b0x144
OR NOT bErrObGasValve AND b0x146
THEN K9_GasValveOpen := TRUE;
ELSE K9_GasValveOpen := FALSE;
END_IF

(*обогрев слива конденсата. если нет режима лето значит агрегат работает в режиме обогрев
и требуется обогрев конденсата*)
IF NOT K13_ModeSummer
THEN K25_OnHeadDrainCondensat := TRUE;
ELSE K25_OnHeadDrainCondensat := FALSE;
END_IF


END_ACTION

ACTION	sayANDpanel:
(*передача данных в панель аварии*)
b0x1 := SEL (bErrVoltageNormal, FALSE, TRUE);
b0x2 := SEL (bErrVoltage, FALSE, TRUE);
b0x3 := SEL (bErrElectricalHeating, FALSE, TRUE);
b0x4 := SEL (bErrBO1ob, FALSE, TRUE);
b0x5 := SEL (bErrBO2ob, FALSE, TRUE);
b0x6 := SEL (bErrBB1On, FALSE, TRUE);
b0x7 := SEL (bErrBB2On, FALSE, TRUE);
b0x8 := SEL (bErrValveHeating, FALSE, TRUE);
b0x9 := SEL (bErrBurner1, FALSE, TRUE);
b0x10 := SEL (bErrBurner2, FALSE, TRUE);
b0x11 := SEL (bErrBurner1and2, FALSE, TRUE);
b0x12 := SEL (bErrBurner3, FALSE, TRUE);
b0x13 := SEL (bErrBurner4, FALSE, TRUE);
b0x14 := SEL (bErrBurner3and4, FALSE, TRUE);
b0x15 := SEL (bErrValveGas, FALSE, TRUE);
b0x16 := SEL (bErrGasPorog1, FALSE, TRUE);
b0x17 := SEL (bErrGasPorog2, FALSE, TRUE);
b0x18 := SEL (bErrFireHangarGPA, FALSE, TRUE);
b0x19 := SEL (bErrFireBlokABGM, FALSE, TRUE);
b0x20 := SEL (bErrPressDropAirFilter, FALSE, TRUE);
b0x21 := SEL (bErrBK101_tempTO1, FALSE, TRUE);
b0x22 := SEL (bErrBK102_tempTO2, FALSE, TRUE);
b0x23 := SEL (bErrBK201_tempTO3, FALSE, TRUE);
b0x24:= SEL (bErrBK202_tempTO4, FALSE, TRUE);
b0x25 := SEL (bErr350_tempTO1, FALSE, TRUE);
b0x26 := SEL (bErr350_tempTO2, FALSE, TRUE);
b0x27 := SEL (bErr350_tempTO3, FALSE, TRUE);
b0x28 := SEL (bErr350_tempTO4, FALSE, TRUE);
b0x29 := SEL (bErrHighCH4Porog, FALSE, TRUE);
b0x30 := SEL (bErrHighCH4Porog2, FALSE, TRUE);
b0x31 := SEL (bErrBK1_tempGas, FALSE, TRUE);
b0x32 := SEL (bErrTempGas, FALSE, TRUE);
b0x33 := SEL (bErrBK2_tempAir, FALSE, TRUE);
b0x34 := SEL (bErr60TempAir, FALSE, TRUE);
b0x35 := SEL (bErr70TempAir, FALSE, TRUE);
b0x36 := SEL (bErr80tempAir, FALSE, TRUE);
b0x37 := SEL (bErrBK3_tempCO, FALSE, TRUE);
b0x38 := SEL (bErr30TempCO, FALSE, TRUE);
b0x39 := SEL (bErr10TempCO, FALSE, TRUE);
b0x40 := SEL (bErrTempCO120, FALSE, TRUE);
b0x41 := SEL (bErrBP1_presAir, FALSE, TRUE);
b0x42 := SEL (bErrBP2_presHing, FALSE, TRUE);
b0x43 := SEL ( bErrBP2_Low , FALSE, TRUE);
b0x44 := SEL (bErrBP2_Hing  , FALSE, TRUE);
b0x45 := SEL (bErrBP3_presLow, FALSE, TRUE);
b0x46 := SEL (bErrBP3_Low , FALSE, TRUE);
b0x47 := SEL (bErrBP3_Hing   , FALSE, TRUE);
b0x48 := SEL (bErrBP101_PressDropTG1, FALSE, TRUE);
b0x49 := SEL (bErrBP102_PressDropTG2, FALSE, TRUE);
b0x50 := SEL (bErrPressDropTG1and2, FALSE, TRUE);
b0x51 := SEL (bErrBP201_PressDropTG3, FALSE, TRUE);
b0x52 := SEL (bErrBP202_PressDropTG4, FALSE, TRUE);
b0x53 := SEL (bErrPressDropTG3and4, FALSE, TRUE);
b0x133 := SEL (K16_ABGMError, TRUE, FALSE);
(*инфа о включенных эл.*)

b0x117 := SEL (K7_BB1On, FALSE, TRUE);
b0x55 := SEL (K22_BB2On, FALSE, TRUE);
b0x120 := SEL (K103_BO1, FALSE, TRUE);
b0x121 := SEL (K103_BO1, FALSE, TRUE);
b0x123 := SEL (K9_GasValveOpen, FALSE, TRUE);
b0x124 := SEL (BP101_PressDropTG1, FALSE, TRUE);
b0x125 := SEL (K105_Burner1Work, FALSE, TRUE);
b0x126 := SEL (BP201_PressDropTG3, FALSE, TRUE);
b0x127 := SEL (K205_Burner3Work, FALSE, TRUE);
b0x128 := SEL (BP102_PressDropTG2, FALSE, TRUE);
b0x129 := SEL (K110_Burner2Work, FALSE, TRUE);
b0x130 := SEL (BP202_PressDropTG4, FALSE, TRUE);
b0x131 := SEL (K210_Burner4Work, FALSE, TRUE);


IF K9_GasValveOpen AND NOT  bErrValveGas
THEN  b0x122 :=TRUE;
ELSE  b0x122 :=FALSE;
END_IF
(*зелёная кнопка*)
b0x137 := SEL (b0x136, FALSE, TRUE);
b0x140 := SEL (b0x139, FALSE, TRUE);
b0x154 := SEL ( b0x142, FALSE, TRUE);
b0x145 := SEL (b0x144, FALSE, TRUE);
b0x143 := SEL (b0x141, FALSE, TRUE);
b0x147 := SEL (b0x146, FALSE, TRUE);

b0x156 := SEL (bButStart, FALSE, TRUE);
b0x157 := SEL (K12_StartABGM, FALSE, TRUE);
b0x158 := SEL (bInReg12_0, FALSE, TRUE);

r4x10 := REAL_TO_INT(BK101_tempTO1);
(*r4x11 := REAL_TO_INT();*)
r4x12 := REAL_TO_INT(BK102_tempTO2);
(*r4x13 := REAL_TO_INT(); *)
r4x14 := REAL_TO_INT(BK1_tempGas);
(*r4x15 := REAL_TO_INT(); *)
r4x16 := REAL_TO_INT(BP3_presLow);
r4x17 := REAL_TO_INT(BK201_tempTO3);
(*r4x18 := REAL_TO_INT();*)
r4x19 := REAL_TO_INT(BK202_tempTO4);
(*r4x20 := REAL_TO_INT();*)
r4x21 := REAL_TO_INT(BP2_presHing);
r4x22 := REAL_TO_INT(BP1_presAir);
r4x23 := REAL_TO_INT(BK2_tempAir);
r4x24 := REAL_TO_INT(TempRoom);
r4x25 := REAL_TO_INT(BK3_tempCO);


(*PID*)

	wPID1prop := r4x37;
	wPID1intg   :=r4x38;
	wPID1diff    := r4x39;

	wPID2prop := r4x40;
	wPID2intg   := r4x41;
	wPID2diff    := r4x42;

(*Нработка*)
MotoHoursBurner1(bDeviceInWork:= K104_StartBurner1, byHour=> wHourBurner1 );
MotoHoursBurner2(bDeviceInWork:= K109_StartBurner2, byHour=> wHourBurner2);
MotoHoursBurner3(bDeviceInWork:= K204_StartBurner3, byHour=>wHourBurner3 );
MotoHoursBurner4(bDeviceInWork:= K209_StartBurner4, byHour=> wHourBurner4);
MotoHoursBO1(bDeviceInWork:= K103_BO1, byHour=> wHourBO1);
MotoHoursBO2(bDeviceInWork:= K203_BO2On, byHour=>wHourBO2);
MotoHoursBB1(bDeviceInWork:= K7_BB1On, byHour=> wHourBB1);
MotoHoursBB2(bDeviceInWork:= K22_BB2On, byHour=> wHourBB2);
r4x27	:= wHourBurner1;
r4x28	:= wHourBurner2 ;
r4x31	:= wHourBurner3 ;
r4x32	:= wHourBurner4 ;
r4x29	:= wHourBO1  ;
r4x33	:= wHourBO2  ;
r4x30	:= wHourBB1  ;
r4x34	:= wHourBB2  ;


(*Задание частоты*)
(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(wRateBO1);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(wRateBO2);
END_IF

(*САУ*)
wSAY_reg0 := REAL_TO_INT (BK101_tempTO1);
wSAY_reg1 := REAL_TO_INT (BK102_tempTO2);
wSAY_reg2 := REAL_TO_INT (BK201_tempTO3);
wSAY_reg3 := REAL_TO_INT (BK202_tempTO4);
wSAY_reg4 := REAL_TO_INT (BK1_tempGas);
wSAY_reg5 := REAL_TO_INT (BK2_tempAir);
wSAY_reg6 := REAL_TO_INT (BK3_tempCO);
wSAY_reg7 := REAL_TO_INT (BP1_presAir);
wSAY_reg8 := REAL_TO_INT (BP2_presHing);
wSAY_reg9 := REAL_TO_INT (BP3_presLow);

bOutReg10_0 := SEL (K1_AlarmOffVoltage  ,FALSE, TRUE);
bOutReg10_1 := SEL (K5_EleHeatingEnable  ,FALSE, TRUE);
bOutReg10_2 := SEL (K4_EleHeatingOff  ,FALSE, TRUE);
bOutReg10_3 := SEL (K103_BO1  ,FALSE, TRUE);
bOutReg10_4 := SEL (K203_BO2On  ,FALSE, TRUE);
bOutReg10_5 := SEL (K7_BB1On  ,FALSE, TRUE);
bOutReg10_6 := SEL (K8_AirBlidVelvOpen  ,FALSE, TRUE);
bOutReg10_7 := SEL (K104_StartBurner1  ,FALSE, TRUE);
bOutReg10_8 := SEL (K109_StartBurner2  ,FALSE, TRUE);
bOutReg10_9 := SEL (K204_StartBurner3  ,FALSE, TRUE);
bOutReg10_10 := SEL (K209_StartBurner4  ,FALSE, TRUE);
bOutReg10_11:= SEL ( K9_GasValveOpen ,FALSE, TRUE);
bOutReg10_12 := SEL (K16_ABGMError  ,FALSE, TRUE);
bOutReg10_13 := SEL (K22_BB2On  ,FALSE, TRUE);
bOutReg10_14 := SEL (K25_OnHeadDrainCondensat  ,FALSE, TRUE);
bOutReg10_15 := SEL ( K10_GasPorog1 ,FALSE, TRUE);
bOutReg11_0 := SEL ( K11_GasPorog2 ,FALSE, TRUE);
bOutReg11_1 := SEL ( SB1_PressKeyErrorStop ,FALSE, TRUE);
bOutReg11_2 := SEL ( bErrVoltage ,FALSE, TRUE);
bOutReg11_3 := SEL (bErrBO1ob  ,FALSE, TRUE);
bOutReg11_4 := SEL ( bErrBO2ob  ,FALSE, TRUE);
bOutReg11_5 := SEL ( bErrBurner1 ,FALSE, TRUE);
bOutReg11_6 := SEL ( bErrBurner2 ,FALSE, TRUE);
bOutReg11_7 := SEL ( bErrBurner3 ,FALSE, TRUE);
bOutReg11_8 := SEL ( bErrBurner4 ,FALSE, TRUE);



SAY_ModeSummer := SEL (  bInReg12_1,FALSE, TRUE);
SAY_ModeHeadGPA := SEL (  bInReg12_2,FALSE, TRUE);

SAY_FireHangarGPA  := SEL ( bInReg12_4 ,FALSE, TRUE);
SAY_FireBlokABGM := SEL ( bInReg12_5 ,FALSE, TRUE);
SAY_HighCH4Porog1 := SEL ( bInReg12_6 ,FALSE, TRUE);
SAY_HighCH4Porog2 := SEL ( bInReg12_7,FALSE, TRUE);

SAY_StartBO1 := SEL ( bInReg12_8 ,FALSE, TRUE);
SAY_StartBO2 := SEL ( bInReg12_9 ,FALSE, TRUE);
SAY_StartBurner1 := SEL ( bInReg12_10 ,FALSE, TRUE);
SAY_StartBurner2 := SEL ( bInReg12_11 ,FALSE, TRUE);
SAY_StartBurner3 := SEL ( bInReg12_12 ,FALSE, TRUE);
SAY_StartBurner4 := SEL ( bInReg12_13 ,FALSE, TRUE);




(*Задание частоты*)
(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(wRateBO1);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(wRateBO2);
END_IF




END_ACTION







