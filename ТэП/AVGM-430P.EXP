

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* если на обоих входих истина, запускается таймер и по истечении
 указаного времяни присваивает зничение на Out=true на оба выхода.
AlarmAND_FB_Res сбросит Out на false на оба выхода если первое условие and не выполняется*)
FUNCTION_BLOCK AlarmAND_FB
VAR_INPUT
	input: BOOL;
	inversion : BOOL;
END_VAR
VAR_OUTPUT
	bError: BOOL;
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT  inversion AND input
THEN ton1.IN := TRUE; (*инверсия*)
ELSE  ton1.IN := FALSE;
END_IF

TON1(PT:= T#15s);

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:= b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (sema1.BUSY, FALSE, TRUE);

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Block_FB (*запоминает аварию после 3 сек и запоминает, сброс restar (блок)*)
VAR_INPUT
	input: BOOL;

END_VAR
VAR_OUTPUT
	bError: BOOL; (*Лакальная переменная*)
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
TON1(
	IN:=input ,
	PT:= T#5s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (sema1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ErrorBurner_FB
VAR_INPUT
	start : BOOL;
	lampWork : BOOL;
	lampAlarm : BOOL;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR
VAR
	TON : TON;
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)
IF start AND NOT lampWork
THEN ton.in := TRUE;
ELSE ton.in := FALSE;
END_IF

TON(PT:= t#120s );

IF ton.q OR lampAlarm
THEN TON1.in := TRUE;
ELSE TON1.in := FALSE;
END_IF


TON1(
	PT:= T#5s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

error := SEL (sema1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK InvAlarm_FB
VAR_INPUT
	inversion: BOOL;
END_VAR
VAR_OUTPUT
	bError: BOOL;
END_VAR
VAR
	TON1 : TON;
	SEMA1 : SEMA;
END_VAR
(* @END_DECLARATION := '0' *)

ton1.IN := SEL (inversion, TRUE, FALSE);  (*инверсия*)

TON1(PT:= T#3s); (*пака  IN=false  на Q=false, как только IN=true через заданое время PT на Q появится true *)

SEMA1(
	CLAIM:=ton1.Q ,
	RELEASE:=b0x0); (*if CLAIM=true of SUSY=true, RELEASE reset. Reset возможен только когда   CLAIM=false*)

bError := SEL (SEMA1.BUSY, FALSE, TRUE);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK UZnoReady_FB (*Неисправность цепей вентилятора обдува*)
VAR_INPUT
	bStart: BOOL;
	bRediness : BOOL; (*Готовность*)
END_VAR
VAR_OUTPUT
	bError : BOOL;
END_VAR
VAR
	SEMA : SEMA;
	TON: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(*Если после старта нет готовности - авария*)

ton(
	IN:= bStart,
	PT:= T#40s);

IF   ton.Q AND NOT bRediness
THEN sema.CLAIM := TRUE;
ELSE sema.CLAIM := FALSE;
END_IF

sema(RELEASE:= b0x0 );

bError := SEL (sema.BUSY, FALSE, TRUE);

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB\/ФБ аварий' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Warning_FB
VAR_INPUT
	input : BOOL;
END_VAR
VAR_OUTPUT
	bWarning: BOOL;
END_VAR
VAR
	TON1 : TON;
END_VAR
(* @END_DECLARATION := '0' *)
TON1(
	IN:=input ,
	PT:= T#5s  );

bWarning := SEL (TON1.Q, FALSE, TRUE );
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FanObduva_FB
VAR_INPUT
	bRun : BOOL;
	bModeMax : BOOL; (*задание на изменение скорости*)
END_VAR
VAR_OUTPUT
	bOutStart: BOOL;
	wRate : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF bRun AND NOT bModeMax
THEN bOutStart := TRUE; wRate := 35;
ELSIF bRun AND  bModeMax
THEN bOutStart := TRUE; wRate := 50;
ELSE  bOutStart := FALSE; wRate := 0;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Gen_Impuls
VAR_INPUT
	enq : BOOL := TRUE;
	PTH : TIME;
	PTL : TIME;
END_VAR
VAR_OUTPUT
	Q : BOOL;
END_VAR
VAR
	tx : TIME;
	tn : TIME;
	init : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF enq THEN
	tx := DWORD_TO_TIME(T_PLC_MS(debug:=0, N :=0, offset :=0));
	IF NOT init THEN init := TRUE; tn := tx; END_IF;
	IF tx - tn >= SEL(Q, PTL, PTH) THEN
		tn := tn + SEL(Q, PTL, PTH);
		Q := NOT Q;
	END_IF;
ELSE
	Q := FALSE;
	init := FALSE;
END_IF;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Heating_FB
VAR_INPUT
	bMode_FB : BOOL;

	wTempCO : REAL;
	wYstPanel : WORD;
	bErrorHeating : BOOL;
	bErrorVolveAir : BOOL;

END_VAR
VAR_OUTPUT
	bHeatingEneble :BOOL;
	bHeatingOff :BOOL;
	bVolveAirEneble :BOOL;
END_VAR
VAR
	bVolve : BOOL;
END_VAR
(* @END_DECLARATION := '0' *)

IF wYstPanel = 0
THEN wYstavkaCO := 24; (*уставка темп в СО по умолчанию*)
ELSE wYstavkaCO:= wYstPanel;
END_IF
(*Управление  EK*)
	 IF  bErrorHeating OR NOT SB1_PressKeyErrorStop
	THEN bHeatingOff := TRUE; bHeatingEneble:= FALSE;
	ELSIF   wTempCO < wYstavkaCO - 1
	THEN bHeatingEneble := TRUE; bHeatingOff := FALSE;
	ELSIF wTempCO > wYstavkaCO + 1
	THEN bHeatingEneble:= FALSE; bHeatingOff := TRUE;
	END_IF

IF  bMode_FB
THEN bVolve := TRUE;
ELSE bVolve := FALSE;
END_IF

	IF BK2_tempAir > wYstavkaCO AND wTempCO < wYstavkaCO -1 AND NOT bErrorVolveAir AND bVolve
	THEN
		bVolveAirEneble := TRUE;
	ELSE
		bVolveAirEneble:= FALSE;
	END_IF



END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Mode5_15
VAR_INPUT
	bSignalSAY : BOOL; (*сигналы на смену режима*)
	bSignalDiscret : BOOL;

	bWork1 : BOOL:= TRUE; (*работать по выходу*)
	bWork2 : BOOL; (*работать по темп в помещении*)
	reTempRoom : REAL;
	reTempExit : REAL;

	wPanelZad1 : WORD; (*задание для окошка ввода значения на панели*)
	wPanelZad2 : WORD;
END_VAR
VAR_OUTPUT
	bPanelTableZad : BOOL; (*Инфо. на панель о смене режима*)
	bPanelTable5_15 : BOOL;
	wZadaniePID_FB: WORD;
	wYstavkaPID_FB : WORD;
	wZad : WORD; (*внутринние задания*)

END_VAR
VAR
	R_TRIG15 :R_TRIG;
	R_TRIG5 :R_TRIG;

END_VAR

(* @END_DECLARATION := '0' *)
(*режим +5 +15 *)
(*бит уведомления задать на прямую т.к. требуется его сброс на панели*)
IF b0x152
THEN bPanelTableZad := TRUE; (*Отк задание по умолчание*)
ELSE bPanelTableZad := FALSE;
END_IF

	IF bSignalDiscret OR bSignalSAY
	THEN wZad := 15;  bPanelTable5_15 := TRUE;
	ELSIF NOT bSignalDiscret AND NOT bSignalSAY
	THEN wZad := 5;  bPanelTable5_15 := FALSE;
	END_IF

IF  bSignalDiscret OR  bSignalSAY(*есть согнал от САУ то включить +15*)
THEN  R_TRIG15.CLK := TRUE;
ELSE R_TRIG15.CLK  := FALSE;
END_IF

IF NOT bSignalDiscret AND NOT bSignalSAY(*если нет согнала то вллючить +5*)
THEN R_TRIG5.CLK  := TRUE;
ELSE R_TRIG5.CLK  := FALSE;
END_IF
(*сброс бита с панели b0x152 *)
R_TRIG15();

R_TRIG5();

IF  R_TRIG15.Q OR R_TRIG5.Q
THEN b0x152 := FALSE;
END_IF

(*задание температуры на ПИД*)
IF bWork1
THEN wZadaniePID_FB:= wPanelZad1;
ELSIF bWork2
THEN wZadaniePID_FB:=  wPanelZad2;
ELSE wZadaniePID_FB:= wZad; wZadaniePID_FB:=  wZad; (*присвоить врутренее задание*)
END_IF

(*Уставка на ПИД*)
IF bWork1
THEN  wYstavkaPID_FB:= REAL_TO_WORD  (reTempExit);
ELSIF bWork2
THEN   wYstavkaPID_FB:= REAL_TO_WORD (reTempRoom);
ELSE  wYstavkaPID_FB:= REAL_TO_WORD  (reTempExit); (*по умолчании работать по дат. на выходе*)
END_IF


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK MotoHours_FB
VAR_INPUT
	bDeviceInWork: BOOL;
END_VAR
VAR_OUTPUT
	byHour : WORD;
END_VAR
VAR
	tm1: TON;
	byMinyt: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
tm1(
	PT := T#60s,
	IN := NOT tm1.Q);

byMinyt := byMinyt + BOOL_TO_WORD (tm1.Q AND bDeviceInWork);

IF byMinyt = 60 THEN (*перевод из минут в часы*)
	byHour := byHour+1;
	byMinyt := 0;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* ПИ-регулятор для управления ИМ2Х0 с двуя командами без сигнала положения(Горелка).
Данный ШИМ-алгоритм орентирован на установление  рассчитанного ПИД-ом (равновесного) положения горелки.
Формула ПИД – приведена к виду с понятным определением коэф-ов, по известной Т1- постоянной времени объекта управления, определяемой по переходной хар-ки.
После выхода из зоны нечуств., П импульс подаётся один раз. (Фактически определяя положение горелки, которое И-составляющая со временем корректирует)
Затем импульсы с периодом "Time_PWM" формирует только И-составляющая. (См. приложенную Временную диаграмму.)
Кп = К * Т1(=КP*TN), Ки = К (=KP), Кд = 0(=К*Т1*Т2)
Задаются пользователем :	Т1 - постоянная времени объекта, К - коэф пропорц. 

FB реализует периодическое, с заданным периодом "Time_PWM", формирование команд управления БОЛЬШЕ и МЕНЬШЕ.
Длительности управляющего воздействия/импульса (выхода регулятора)  расчитывается  ПИ-алгоритмом.  
ПИД-алгоритм реализован путём замены операторов диф-я и интегрирования в классическом уравнении ПИД-регулятора 
конечными разностями и конечными суммами :  
 	Y:=Y_OFFSET+ КК * KP * TN * ERROR + I.OUT + D.OUT * TV * ERROR / ABS(ERROR)  + Y_ADDOFFSET. 
	КК - исп. для исключения П-составляющей, после выдачи первого управляющего импульса	после выхода из зоны нечуств-ти.
ПИД-алгоритм работает при условии Кп <>0 И Ки >0.
*)
(*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
FUNCTION_BLOCK PID_PWM_ASUPRO
VAR_INPUT
	ACTUAL :REAL;				(* Регулируемый параметр		actual value, process variable *)
	SET_POINT:REAL;			(*ЗДН			 desired value, set point *)
	KP:REAL;						(*К-коэффициент  =0.01*)
	TN:REAL;						(*Т1- постоянная времени объекта, с  *)
	TV:REAL;						(*Т2-коэффициент	rate time, derivative time (D) in sec*)
	D_ZONE: REAL;				(*Зона нечувствительности*)
	AVT_REG: BOOL;				(* АВТ/ДУ (True)*)
	kn_RUCH_Y_UP: BOOL;		(*Вход "ОТКРЫТЬ" при ДУ управлении*)
	kn_RUCH_Y_DOWN: BOOL;		(*Вход "ЗАКРЫТЬ" при ДУ останове*)
	Time_PWM :INT; 			(*Период ШИМ, измеряется в циклах программы  100*0,3c = 30 c*)
END_VAR
VAR
	LIMITS_ACTIVE:BOOL:=FALSE;	(* Флаг при достижении Y заданных границ					true set value would exceed limits Y_MIN, Y_MAX *)
	OVERFLOW:BOOL:=FALSE;		(* Флаг переполнения Интегратора			overflow in integral part *)
END_VAR
VAR
	CLOCK:TON;					(*таймер исп-ся для определения времени цикла вызова ПИД - dt*)
	I: INTEGRAL;					(*Интегратор*)
	D: DERIVATIVE;				(**)
	TMDIFF: DWORD;				(*dt - время цикла вызова регулятора исп-ся  для диф-ния, мс *)
	ERROR: REAL;				(**)(*внутренний Ошибка*)
	INIT: BOOL:=TRUE;			(*Флаг первичной инициализации, при старте*)
	Y_ADDOFFSET: REAL;		(*величина Добавочного смещение для Y*)
	KPcopy:REAL;					(*внутренний Кп*)
	TNcopy:REAL;					(*внутренний Ки*)
	TVcopy:REAL;					(*внутренний Кд*)
	ERROR_RASCH: REAL;		(*внутренний Ошибка*)
	Y	:	REAL;					(*Выход ПИД = Рассчитываемое алгоритмом Управляющее воздействие , -100...+100*)
	Tof_UP: TOF;					(**)
	Tof_DOWN: TOF;				(**)
	RESET:BOOL;					(* команда сброса Y в Y_OFFSET и сброс интегральной составляющей 		reset: set Y output to Y_OFFSET and reset integral part *)
	Y_MANUAL:REAL;				(*Если режим ДУ, то Y = этому значению   			Y is set to this value as long as MANUAL=TRUE *)
	Y_OFFSET: REAL := 0;		(* Смещение для управляющей	переменной		offset for manipulated variable*)
	Y_MIN: REAL := -100;			(* Граница Мин. Y			minimum value for manipulated variable*)
	Y_MAX: REAL := 100;			(* Граница Макс.Y		maximum value for manipulated variable*)
	MANUAL:BOOL;				(* 	TRUE: manual: Y is not influenced by controller,		FALSE: controller determines Y *)
	KK: REAL := 1;					(*гаа : Флаг разрешения  П-составляющей*)
END_VAR

VAR_OUTPUT
	Y_UP:BOOL; 				(*Управляющий выход на ИМ - БОЛЬШЕ*)
	Y_DOWN: BOOL;			(*Управляющий выход на ИМ - МЕНЬШЕ*)
	D_ZONE_: BOOL;			(*Зона нечувствительности*)
END_VAR

VAR
	T_PWM: REAL;		(*Длительность  управляющей команды, расчитанное ПИД*)
	Counter: INT;			(*Счетчик, необходим для счета времени ШИМа*)
	Sbros: BOOL;			(*внутренняя команда сброса, при входе в зону нечуств-ти*)
END_VAR
(* @END_DECLARATION := '0' *)
(*Определение величины Ошибки*)
IF (SET_POINT - D_ZONE) <= ACTUAL AND (SET_POINT+D_ZONE >= ACTUAL)
THEN ERROR_RASCH:=0; KK:= 1; D_ZONE_:= TRUE; (*гаа : Разрешение П-составляющей*)
           ELSIF (SET_POINT- D_ZONE) > ACTUAL
            THEN ERROR_RASCH := SET_POINT - ACTUAL - D_ZONE; D_ZONE_:= FALSE;
                        ELSIF (SET_POINT+D_ZONE) < ACTUAL
                        THEN ERROR_RASCH := SET_POINT - ACTUAL + D_ZONE; D_ZONE_:= FALSE;
END_IF

(*Сброс Интегратора если Ошибка = 0 (если регулируемый параметр в зоне нечуств-ти) *)
IF Sbros=1 THEN RESET:=1; ELSE RESET:=0;  END_IF
(*=====ПИД-алгоритм================================================================================================*)
IF TN > 0 AND KP <> 0 THEN
	ERROR := ERROR_RASCH;								(* Regeldifferenz *)

	IF OVERFLOW OR RESET OR MANUAL OR INIT OR (KP<>KPcopy OR TN<>TNcopy OR TV<>TVcopy) THEN		(* Reset ИЛИ ДУ (Handbetrieb)  ИЛИ Инициализация ИЛИ изменились коэф-ы ПИД-а*)
		I(RESET:=TRUE);		(*Сброс интегратора*)
		D(RESET:=TRUE);
		OVERFLOW:=FALSE;
		LIMITS_ACTIVE:=FALSE;
		IF RESET OR INIT THEN 		 (* Reset ИЛИ Инициализация*)
			Y := Y_OFFSET;			(*Сброс Y*)
			INIT:=FALSE;				(*Сброс флага Инициализации*)
			Y_ADDOFFSET := 0;
		ELSIF MANUAL THEN		(*если режим ДУ*)
			Y := Y_MANUAL;
			Y_ADDOFFSET := Y_MANUAL-(Y_OFFSET+ KP * TN* ERROR + I.OUT + D.OUT*TV);  (*смещени = ЗДН ДУ - *)
		ELSE
			Y_ADDOFFSET := Y - Y_OFFSET - KP * TN * ERROR;		(*смещение  = *)
		END_IF
		TMDIFF:=0;
		CLOCK(IN:=FALSE);									(* Timer neu starten *)
		CLOCK(PT:=t#1h, IN:=TRUE);						(*Запуск 1 ч таймера, исп. для определения времени цикла TMDIFF *)
		(*Копирование коэф-ов ПИД во внутренние переменные, чтобы затем определять момент их изменения*)
		TNcopy := TN;
		TVcopy := TV;
		KPcopy := KP;
	ELSE
		CLOCK;												(* Работа таймера			Timer abfragen *)
		TMDIFF:=TIME_TO_DWORD(CLOCK.ET);			(*Определение времени цикла					Zeitdifferenz seit letztem Aufruf *)
	END_IF;
    (*-------Расчёт ПИД в каждый dt -отсчёт времени ------------------------------------------------------------*)
	IF TMDIFF > 0 THEN
		CLOCK(IN:=FALSE);									(* Timer neu starten *)
		CLOCK(PT:=t#1h, IN:=TRUE);						(*Запуск 1 ч таймера, исп. для определения времени цикла TMDIFF *)

		D(IN:=ERROR, TM:=TMDIFF, RESET:=FALSE);				(* Определение Диф. составляющей			Differential abschдtzen *)
		I(IN:=ERROR*KP, TM:=TMDIFF, RESET:=FALSE);				(* Определение Интегр. составляющей 		Integral abschдtzen *)    (*гаа : добавил, как у СС, K в интегратор*)

		OVERFLOW := I.OVERFLOW;
		IF NOT OVERFLOW THEN		(*Если нет переполнения Интегратора *)
			Y:=Y_OFFSET+ KK * KP * TN * ERROR + I.OUT + D.OUT * TV * ERROR / ABS(ERROR)  + Y_ADDOFFSET;  (*****Формула ПИД !********гаа : Д составляющая c учётом знака Ошибки*)
			IF Y>1E30 OR Y<-1E30 THEN						(* Обработка возможного переполнения 		Overflow steht bevor, darf aber eigentlich nicht passieren *)
				OVERFLOW:=TRUE;
			END_IF;

			LIMITS_ACTIVE:=FALSE;
			IF Y_MAX>Y_MIN AND Y>Y_MAX  THEN				(* Проверка превышения Макс. границ 	Stellwert-Obergrenze ьberschritten *)
				LIMITS_ACTIVE:=TRUE;
				IF KP<>0 THEN		(*Если Кп не 0, то корректировка Интегральной составляющей*)
					I(IN:=(Y_MAX-Y)*TN/KP,TM:=1000,RESET:=FALSE);		(* Integral korrigieren *) (**)
				END_IF
				Y:=Y_MAX;	(*Ограничиваем Y значением Y_MAX*)
			END_IF;
			IF Y_MAX>Y_MIN AND Y<Y_MIN THEN					(* Проверка превышения Мин. границы	Stellwert-Untergrenze unterschritten *)
				LIMITS_ACTIVE:=TRUE;
				IF KP<>0 THEN
					I(IN:=(Y_MIN-Y)*TN/KP,TM:=1000,RESET:=FALSE);		(* Integral korrigieren *)
				END_IF
				Y:=Y_MIN; 	(*Ограничиваем Y значением Y_MAX*)
			END_IF;
		END_IF;
	ELSE
		CLOCK(PT:=t#1h,IN:=TRUE);
	END_IF;
	(*----------------------------------------------------------------------------------------------------------------------*)
END_IF;
(*=========================================================================================================================*)
(**************Формирование ШИМ************************************)
IF ERROR_RASCH=0 THEN Sbros:=1;Counter:=0; ELSE Sbros:=0; Counter:=Counter+1;  END_IF;  (*Если вошли в зону  нечуств., то СБРОС*)
IF Counter > Time_PWM THEN Counter:=0; (*Sbros:=1; ELSE Sbros:=0;*) END_IF;

T_PWM:=INT_TO_REAL(Time_PWM)*(Y/100);		(*Приведение расчитанного Y к длительности в циклах программы(вызова ПИД)*)
(*------------------------------------------------------------------------------*)
(*Управление на закрыие*)
IF (Counter<T_PWM*-1 AND ERROR_RASCH<>0 AND AVT_REG=1 AND Y_UP=0 AND Tof_UP.Q=0)OR
   (AVT_REG=0 AND Y_UP=0 AND kn_RUCH_Y_DOWN=1 AND kn_RUCH_Y_UP=0)
		THEN Y_DOWN:=TRUE;
			ELSIF (Counter>T_PWM OR ERROR_RASCH=0)  THEN Y_DOWN:=FALSE;
ELSE Y_DOWN:=FALSE;
END_IF;
Tof_DOWN(IN:=Y_DOWN , PT:=(*T#0.2S*) , Q=> , ET=> );

(*Управление на открытие*)
IF (Counter<T_PWM AND ERROR_RASCH<>0 AND AVT_REG=1 AND Y_DOWN=0 AND Tof_DOWN.Q=0) OR
    (AVT_REG=0 AND Y_DOWN=0 AND kn_RUCH_Y_UP=1 AND kn_RUCH_Y_DOWN=0)
		THEN Y_UP:=TRUE;
			ELSIF Counter>T_PWM OR ERROR_RASCH=0 THEN Y_UP:=FALSE;
ELSE Y_UP:=FALSE;
END_IF;

Tof_UP(IN:=Y_UP , PT:=T#0.2S , Q=> , ET=> );  (*Таймер введён для задержки исключающей одновременную подачу Y_UP и Y_DOWN ?*)
(*------------------------------------------------------------------------------*)
IF Counter > ABS(T_PWM) AND TMDIFF > 0 THEN KK := 0; END_IF;  (*гаа : Сброс П-составляющей после первого импульса после выхода из зоны нечуств-и*)

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK SwBurner_FB
VAR_INPUT
	bInput1 : BOOL;
	bInput2 : BOOL;
	rZad1 : REAL;  		(*гаа : расчитанная мощность Г1, %*)
	rZad2 : REAL;		(*гаа : расчитанная мощность Г2, %*)
	Y_UP : BOOL; 		(*гаа : Команда БОЛЬШЕ от ПИД *)
	Y_DOWN : BOOL; 		(*гаа : Команда МЕНЬШЕ от ПИД *)
	bInWork1 : BOOL;
	bInWork2 : BOOL;
	bInError1 : BOOL;
	bInError2 : BOOL;
	wHourBurner1 : WORD;
	wHourBurner2 : WORD;
	rTempTO1 : REAL;
	rTempTO2 : REAL;
	bD_Zone: BOOL; (*ПИД в зоне нечувствительности*)
END_VAR
VAR_OUTPUT
	bPIDmax1 : BOOL;  (*гаа - команда формировать импульсы на БОЛЬШЕ мощность Г1(3)*)
	bPIDmin1 : BOOL; (*гаа - команда формировать импульсы на МЕНЬШЕ мощность Г1(3)*)
	bPIDmax2 : BOOL; (*гаа - команда формировать импульсы на БОЛЬШЕ мощность Г2(4)*)
	bPIDmin2: BOOL; (*гаа - команда формировать импульсы на МЕНЬШЕ мощность Г2(4)*)
	bStartPower1 : BOOL;
	bStartPower2 : BOOL;
END_VAR
VAR
	bMode : BYTE;
	bModeBurner : BYTE;
	tonIN1 : TON;
	tonIN2 : TON;
	tofIN1 : TON;
	tofIN2 : TON;
	R_TRIG1 : R_TRIG;
	R_TRIG2 : R_TRIG;
	bResetBurner : BOOL;
	TP1: TP;
	TON_OnRez1: TON;
	TON_OnRez2: TON;
	TON_OffRez1: TON;
	TON_OffRez2: TON;
	TP_BurnerDec: TP;

END_VAR
(* @END_DECLARATION := '0' *)
(*сброс на модули задания мощности*)
R_TRIG1(CLK:= bInput1 , Q=> );
R_TRIG2(CLK:= bInput2 , Q=> );

IF R_TRIG1.Q OR R_TRIG2.Q THEN
	TP1.IN := TRUE;
ELSE
	TP1.IN := FALSE;
END_IF

TP1( PT:= t#5s , Q=> , ET=> );  (*гаа : задержка 5с на включение горелки*)
(*------------------------------------------Пуск горелок------------------------------ *)
IF bInput1 OR bInput2
	THEN
	(*сброс*)
	IF TP1.Q THEN
		bModeBurner := 0;
	ELSE (*проверка горелок готовых к запуску по выбору с панели*)
		IF bInput1 AND NOT bInError1 AND bModeBurner=0
			THEN bModeBurner:= 1;
		ELSIF bInput1 AND bInError1
				THEN bModeBurner:= 2;
		END_IF
		IF bInput2 AND NOT bInError2 AND bModeBurner=0
			THEN bModeBurner:= 2;
		ELSIF bInput2 AND bInError2
				THEN bModeBurner:= 1;
		END_IF
		(*При разрешении двух горелок выбираем основную по наработке *)
		IF (bInput1 AND bInput2 AND NOT bInError1 AND NOT bInError2 AND wHourBurner1 <= wHourBurner2 AND bModeBurner<=2) OR
		  	(bModeBurner=5 AND TON_OffRez2.Q) (* Останов резервной горелки при её мин мощности в течении 60 сек*)
			THEN bModeBurner:= 3;
		END_IF
		IF (bInput1 AND bInput2 AND NOT bInError2 AND NOT bInError1 AND wHourBurner2 < wHourBurner1 AND bModeBurner<=2) OR
			(bModeBurner=6 AND TON_OffRez1.Q) (* Останов резервной горелки при её мин мощности в течении 60 сек*)
			THEN bModeBurner:= 4;
		END_IF  (* Запуск резервной горелки при макс мощности основной в течении 60 сек*)
		IF bInput1 AND NOT bInError1 AND bInput2 AND NOT bInError2 AND bModeBurner=3 AND TON_OnRez2.Q
			THEN bModeBurner:= 5;
		END_IF  (* Запуск резервной горелки при макс мощности основной в течении 60 сек*)
		IF bInput1 AND NOT bInError1 AND bInput2 AND NOT bInError2 AND bModeBurner=4 AND TON_OnRez1.Q
			THEN bModeBurner:= 6;
		END_IF
	END_IF
ELSE  bModeBurner:= 0;
END_IF

IF bModeBurner=3 THEN
	TON_OffRez2(IN:= FALSE);
	TON_OnRez2(IN:= (tofIN2.Q AND NOT bD_Zone AND rZad1=100), PT:= T#60S); (*Горелка 1 на макс.мощности*)
ELSIF
	bModeBurner=4 THEN
	TON_OffRez1(IN:= FALSE);
	TON_OnRez1(IN:= (tofIN1.Q AND NOT bD_Zone AND rZad2=100), PT:= T#60S); (*Горелка 2 на макс.мощности*)
ELSIF
	bModeBurner=5 THEN
	TON_OnRez2(IN:= FALSE);
	TON_OffRez2(IN:= (tonIN2.Q AND NOT bD_Zone AND rZad2=0), PT:= T#60S); (*Горелка 2 на мин.мощности*)
ELSIF
	bModeBurner=6 THEN
	TON_OnRez1(IN:= FALSE);
	TON_OffRez1(IN:= (tonIN1.Q AND NOT bD_Zone AND rZad1=0), PT:= T#60S); (*Горелка 1 на мин.мощности*)
ELSE
	TON_OnRez1(IN:= FALSE);
	TON_OnRez2(IN:= FALSE);
	TON_OffRez1(IN:= FALSE);
	TON_OffRez2(IN:= FALSE);
END_IF

CASE bModeBurner OF
0 : bStartPower1 := FALSE; bStartPower2 := FALSE;
1 : bStartPower1 := TRUE;  bStartPower2 := FALSE;
2 : bStartPower1 := FALSE; bStartPower2 := TRUE;
3 : bStartPower1 := TRUE;  bStartPower2 := FALSE;
4 : bStartPower1 := FALSE; bStartPower2 := TRUE;
5 : bStartPower1 := TRUE;  bStartPower2 := TRUE;
6 : bStartPower1 := TRUE;  bStartPower2 := TRUE;
END_CASE

(*-------------------------------------------Управление мощностью горелок -------------------------------------------------*)
(* Выдержать паузу после вкл/откл горелки для стабилизации и избежания перерегулирования Т, далее управляем мощностью *)
tonIN1(IN:= bInWork1, PT:= T#3M);
tonIN2(IN:= bInWork2, PT:= T#3M);
tofIN1(IN:= NOT bInWork1, PT:= T#3M);
tofIN2(IN:= NOT bInWork2, PT:= T#3M);
IF NOT TP1.Q THEN
	IF (bModeBurner=1 OR bModeBurner=3) AND NOT PLC_PRG.Alarm.bErr70TempAir (*в работе только горелка 1*)
		THEN
		IF  Y_UP AND NOT Y_DOWN AND (rZad1<>100) AND tonIN1.Q
			THEN bMode :=1; (*команда БОЛЬШЕ мощ Г 1 *)
		END_IF
		IF  Y_DOWN AND NOT Y_UP AND (rZad1<>0) AND tofIN2.Q
			THEN bMode :=2; (* команда МЕНЬШЕ мощ Г 1*)
		END_IF
		IF NOT Y_UP AND NOT Y_DOWN (*если нет команд от ПИД то снять команды*)
			THEN bMode :=0;
		END_IF
	ELSIF (bModeBurner=2 OR bModeBurner=4) AND NOT PLC_PRG.Alarm.bErr70TempAir(*в работе только горелка 2*)
		THEN
		IF  Y_UP AND NOT Y_DOWN  AND (rZad2<>100) AND tonIN2.Q
			THEN bMode :=3; (*команда БОЛЬШЕ мощ Г 2 *)
		END_IF
		IF  Y_DOWN AND NOT Y_UP  AND (rZad2<>0) AND tofIN1.Q
			THEN bMode :=4; (* команда МЕНЬШЕ мощ Г 2*)
		END_IF
		IF NOT Y_UP AND NOT Y_DOWN (*если нет команд от ПИД то снять команды*)
			THEN bMode :=0;
		END_IF
	ELSIF bModeBurner=5  (*в работе основная горелка 1 и резервная горелка 2*)
		THEN
		(*Делим мощности горелок между собой для избежания перерегулирования Т и переключений при запуске рез.горелки*)
		IF	(rZad1>80) THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=2;
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			END_IF
		ELSE
			bMode:=0;
			TP_BurnerDec.IN := FALSE;
		END_IF
		(*Управление мощностью резервной горелки 2*)
		IF  Y_UP AND NOT Y_DOWN AND (rZad2<>100) AND tonIN2.Q
			THEN bMode :=3; (*команда БОЛЬШЕ мощ Г 2 *)
		END_IF
		IF  Y_DOWN AND NOT Y_UP AND (rZad2<>0)
			THEN bMode :=4; (* команда МЕНЬШЕ мощ Г 2*)
		END_IF
		IF NOT Y_UP AND NOT Y_DOWN (*если нет команд от ПИД то не подавать команды*)
			THEN bMode :=0;
		END_IF
	ELSIF bModeBurner=6 (*в работе основная горелка 2 и резервная горелка 1*)
		THEN
		(*Делим мощности горелок между собой для избежания перерегулирования Т и переключений при запуске рез.горелки*)
		IF	(rZad2>80) THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=4;
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			END_IF
		ELSE
			bMode:=0;
			TP_BurnerDec.IN := FALSE;
		END_IF
		(*Управление мощностью резервной горелки 1*)
		IF  Y_UP AND NOT Y_DOWN AND (rZad1<>100) AND tonIN1.Q
			THEN bMode :=1; (*команда БОЛЬШЕ мощ Г 1 *)
		END_IF
		IF  Y_DOWN AND NOT Y_UP AND (rZad1<>0)
			THEN bMode :=2; (* команда МЕНЬШЕ мощ Г 1*)
		END_IF
		IF NOT Y_UP AND NOT Y_DOWN (*если нет команд от ПИД то не подавать команды*)
			THEN bMode :=0;
		END_IF
	END_IF
	IF PLC_PRG.Alarm.bErr70TempAir THEN  (* если неисправность по высокой Т *)
		IF bModeBurner=1 OR bModeBurner=3 AND rZad1>35 THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=2; (* то уменьшить мощность Г1*)
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			END_IF
		END_IF

		IF bModeBurner=2 OR bModeBurner=4 AND rZad2>35 THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=4; (* то уменьшить мощность Г2*)
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			END_IF
		END_IF

		IF bModeBurner=5 AND rZad1>35 THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=5; (* то уменьшить мощность Г1 и Г2*)
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner1_Tmax));
			END_IF
		ELSIF bModeBurner=5 AND rZad1<35 THEN
			bModeBurner:=3;
		END_IF

		IF bModeBurner=6 AND rZad2>35 THEN
			TP_BurnerDec(IN := TRUE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			IF TP_BurnerDec.Q THEN
				bMode:=5; (* то уменьшить мощность Г1 и Г2*)
			ELSE
				bMode:=0;
				TP_BurnerDec(IN := FALSE, PT := UINT_TO_TIME(uiBurner2_Tmax));
			END_IF
		ELSIF bModeBurner=6 AND rZad2<35 THEN
			bModeBurner:=4;
		END_IF
	END_IF
ELSE
bPIDmax2:=FALSE;bPIDmin2 :=FALSE;
(* bMode := 0;*)
END_IF

(*reset*)
IF NOT bInput1 AND NOT bInput2
THEN bMode := 0;
END_IF

CASE bMode OF
0 : bPIDmax1:=FALSE; bPIDmin1:=FALSE; bPIDmax2:=FALSE; bPIDmin2:=FALSE;
1 : bPIDmax1:=TRUE;  bPIDmin1:=FALSE; bPIDmax2:=FALSE; bPIDmin2:=FALSE; (* команда БОЛЬШЕ мощ Г 1*)
2 : bPIDmax1:=FALSE; bPIDmin1:=TRUE;  bPIDmax2:=FALSE; bPIDmin2:=FALSE; (* команда МЕНЬШЕ мощ Г 1*)
3 : bPIDmax1:=FALSE; bPIDmin1:=FALSE; bPIDmax2:=TRUE;  bPIDmin2:=FALSE; (* команда БОЛЬШЕ мощ Г 2*)
4 : bPIDmax1:=FALSE; bPIDmin1:=FALSE; bPIDmax2:=FALSE; bPIDmin2:=TRUE;  (* команда МЕНЬШЕ мощ Г 2*)
5 : bPIDmax1:=FALSE; bPIDmin1:=TRUE;  bPIDmax2:=FALSE; bPIDmin2:=TRUE;  (* команда МЕНЬШЕ мощ Г 1 и 2*)
END_CASE
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Switcher_FB
VAR_INPUT
	bStart1 : BOOL;
	bStart2 : BOOL;
	bError1 : BOOL;
	bError2: BOOL;
	bStart_out1_2 : BOOL;
END_VAR
VAR_OUTPUT
	bOut1 : BOOL;
	bOut2 : BOOL;
	bOutError1 : BOOL;
	bOutError2 : BOOL;
END_VAR
VAR
	Gen_Impuls1: Gen_Impuls;
	Gen_Impuls2: Gen_Impuls;
	bGen1Out1: BOOL;
	bGen1Out2: BOOL;
	bGen2Out1: BOOL;
	bGen2Out2: BOOL;
END_VAR
(*FB выполняет функцию переключения двух элементов, по заданому времени.
Также вывод элемента из цикла если пришла команда авария и запуск 
второго.
Запуск обоих элементов по сигналу*)

(* @END_DECLARATION := '0' *)
IF  bStart1  AND NOT bStart2
THEN Gen_Impuls1.enq := TRUE;
ELSE Gen_Impuls1.enq := FALSE;
END_IF

IF  bStart2 AND NOT bStart1
THEN Gen_Impuls2.enq := TRUE;
ELSE Gen_Impuls2.enq := FALSE;
END_IF

Gen_Impuls1( PTH:= t#12h, PTL:= t#12h);
(*Раздвоеие генератора и поочерёдное включение двух выходов*)
IF Gen_Impuls1.Q
THEN  bGen1Out2 := TRUE; (*переключение выходов*)
ELSE bGen1Out2 := FALSE;
END_IF
 	IF NOT Gen_Impuls1.Q
	THEN bGen1Out1  := TRUE; (*переключение выходов*)
	ELSE bGen1Out1 := FALSE;
	END_IF
		IF NOT Gen_Impuls1.enq
		THEN bGen1Out1 := FALSE; bGen1Out2 := FALSE;
		END_IF

Gen_Impuls2( PTH:= t#12h, PTL:= t#12h );

IF Gen_Impuls2.Q
THEN bGen2Out2 := TRUE; (*переключение выходов*)
ELSE bGen2Out2 := FALSE;
END_IF
 	IF NOT Gen_Impuls2.Q
	THEN bGen2Out1 := TRUE; (*переключение выходов*)
	ELSE bGen2Out1 := FALSE;
	END_IF
		IF NOT Gen_Impuls2.enq
		THEN bGen2Out1 := FALSE; bGen2Out2 := FALSE;
		END_IF

IF (bGen1Out1 AND bStart1 AND NOT bError1)
	OR bError2 OR bStart_out1_2
THEN bOut1 := TRUE;
ELSE bOut1 := FALSE;
END_IF

IF (bGen2Out1 AND bStart2 AND NOT bError2)
	OR bError1 OR bStart_out1_2
THEN bOut2 := TRUE;
ELSE bOut2 := FALSE;
END_IF

IF bError1 AND bError2
	THEN bOut1 := FALSE; bOut2 := FALSE;
END_IF

(*отправить аварию дальше *)
IF bError1
THEN bOutError1 := TRUE;
ELSE bOutError1 := FALSE;
END_IF

IF  bError2
THEN bOutError2 := TRUE;
ELSE bOutError2 := FALSE;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ZadPower_FB
VAR_INPUT
	bStart : BOOL;
	bPIDmax : BOOL;  (*гаа - формировать импульсы на Увеличивать мощность*)
	bPIDmin : BOOL;  (*гаа - формировать импульсы на МЕНЬШЕ мощность*)
	t_min : UINT; 	(*мин.длительность команды, мсек*)
	t_max : UINT; 	(*макс.длительность команды, мсек*)
	uiFullMove : UINT;  (*время полного хода горелки, с*)
END_VAR
VAR_OUTPUT
	bOpen1 : BOOL;
	bClose1 : BOOL;
	rCur_power : REAL; (*значение мощности*)
	bStartBurner : BOOL;
END_VAR
VAR
	TON_open: TON;
	TON_close : TON;
	TOF_open: TOF;
	TOF_close : TOF;
	F_TRIG_open: F_TRIG;
	F_TRIG_close: F_TRIG;
	T_open_Moment: TIME;
	T_close_Moment: TIME;
	T_open_Full: TIME;
	T_close_Full: TIME;
	rOpen_Full: REAL;
	rClose_Full: REAL;
	TON_FullMove_open: TON;
	TON_FullMove_close: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(*старт горелки *)
bStartBurner := bStart;
(*регулирование мощности горелки*)
IF bStart THEN
	TON_open(
		IN:= bPIDmax,
		PT:= UINT_TO_TIME(t_max));
	TON_close(
		IN:= bPIDmin,
		PT:= UINT_TO_TIME(t_max));

	(*Выдача команд УВ на ОР*)
	bOpen1 := bPIDmax AND NOT TON_open.Q;
	bClose1 := bPIDmin AND NOT TON_close.Q;

	(*Подсчёт длительности команд УВ*)
	F_TRIG_open(CLK:=bOpen1);
	IF bOpen1 THEN
		TON_FullMove_open(IN:=TRUE, PT:=UINT_TO_TIME(uiFullMove*1000));
	ELSIF F_TRIG_open.Q THEN
		TON_FullMove_open(ET=>T_open_Moment); TON_FullMove_open(IN:=FALSE);
		T_open_Full:= T_open_Full+T_open_Moment;
	END_IF
	F_TRIG_close(CLK:=bClose1);
	IF bClose1 THEN
		TON_FullMove_close(IN:=TRUE, PT:=UINT_TO_TIME(uiFullMove*1000));
	ELSIF F_TRIG_close.Q THEN
		TON_FullMove_close(ET=>T_close_Moment); TON_FullMove_close(IN:=FALSE);
		T_close_Full:= T_close_Full+T_close_Moment;
	END_IF
ELSE
	T_open_Full:=T#0MS;
	T_close_Full:=T#0MS;
	F_TRIG_open(CLK:=FALSE);
	F_TRIG_close(CLK:=FALSE);
	TON_FullMove_open(IN:=FALSE);
	TON_FullMove_close(IN:=FALSE);
END_IF

(*Дататипизация*)
rOpen_Full:=TIME_TO_REAL(T_open_Full) / 1000;
rClose_Full:=TIME_TO_REAL(T_close_Full) / 1000;
(*Контроль границ*)
IF	rOpen_Full-rClose_Full > uiFullMove THEN
	T_open_Full:= UINT_TO_TIME(uiFullMove*1000);
	T_close_Full:= T#0MS;
	rOpen_Full:= uiFullMove;
	rClose_Full:= 0;
ELSIF
	rOpen_Full-rClose_Full < 0 THEN
	T_open_Full:= T#0MS;
	T_close_Full:= T#0MS;
	rOpen_Full:= 0;
	rClose_Full:= 0;
END_IF

(*Расчёт %мощности горелки от длительности выданных команд УВ и времени полного хода горелки, замеренного по факту, введенного с панели*)
rCur_power:= (rOpen_Full - rClose_Full) * 100 / uiFullMove;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION funUZ100_4_20mA : WORD (*Преобразование для ПЧ с диапазона 0..50 на 0..1000*)
VAR_INPUT
	Gerc : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
funUZ100_4_20mA := Gerc * 20;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION funUZ200_4_20mA : WORD (*Преобразование для ПЧ с диапазона 0..50 на 0..1000*)
VAR_INPUT
	Gerc : WORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
funUZ200_4_20mA := Gerc * 20;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Функции' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION T_PLC_MS : DWORD
VAR_INPUT
	debug : BOOL := 0;
	N : INT := 0;
	offset : DWORD := 0;
END_VAR
VAR
	tx : TIME;
END_VAR
(*T_PLC_MS читает внутренними PLC таймер и вернуть время, он имеет преимущество, чтобы иметь возможность установить режим отладки
и ускорить счетчик для проверки ПЛК переполнения таймера, которое происходит раз в 50 дней, соответственно 25 дней на Сименс S7
эта процедура также позволяет корректировать поведение С7, где внутренний ПЛК счетчик не будет считать все 32 бита*)
(* @END_DECLARATION := '0' *)
tx := TIME();
T_PLC_MS := TIME_TO_DWORD(Tx);
(* здесь коррекция должна состояться step7
plctime нужно воспользоваться полного диапазона значений времени:
если у step7 time -24tage до плюс 24 дня должен то таймер при переполнении на -24tage прыгать 
и ни в коем случае на 0 !!!!
для siemens еще один ФБ должен быть включен в Майне представляет из себя учитываются все 32 бит через.
это только ФБ может быть он должен помнить, Верховный (32te) бит.
или около spring s7 при переполнении на -24 дней????? тогда без коррекции будет необходимо.
*)
IF debug THEN
	T_PLC_MS := (SHL(T_PLC_MS,N) OR SHL(DWORD#1,N)-1) + OFFSET;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PLC_PRG
VAR
	Block_normVoltage : Block_FB;
	invAlarm_Voltage: InvAlarm_FB;

	AlarmAND_BB1On :AlarmAND_FB;
	AlarmAND_BB2On :AlarmAND_FB;
	invAlarm_BO1Error: InvAlarm_FB;
	invAlarm_BO2Error: InvAlarm_FB;
	UZnoReady_BO1Got : UZnoReady_FB;
	UZnoReady_BO2Got : UZnoReady_FB;

	bEnebleTonHeating: BOOL;		(*Включить счётчик 300 сек на аварию эл обогревателя*)
	rtEnebleHeating: R_TRIG;
	rTempCO: REAL;
	TonHeating: TON;
	TofHeating: TOF;
	Block_ElectricalHeating: Block_FB;
	bK3Off : BOOL; (*к3 не включился*)

	rTempCOValve: REAL;(*Включить счётчик 120 сек на аварию клапана обдува*)
	TonHeatingValve: TON;
	Block_ValveHeating: Block_FB;
	bErrValveHeating: BOOL;

	bErrVoltage: BOOL;
	bErrElectricalHeating: BOOL;
	bErrVoltageNormal: BOOL;
	bErrBO1: BOOL;
	bErrBO2: BOOL;
	bNotBO1Got: BOOL;
	bNotBO2Got: BOOL;
	bErrBB1On: BOOL;
	bErrBB2On: BOOL;
	ErrorBurner4: ErrorBurner_FB;
	ErrorBurner3: ErrorBurner_FB;
	ErrorBurner2: ErrorBurner_FB;
	ErrorBurner1: ErrorBurner_FB;
	bErrBurner1: BOOL;
	bErrBurner2: BOOL;
	bErrBurner3: BOOL;
	bErrBurner4: BOOL;
	bErrBurner1and2: BOOL;
	bErrBurner3and4: BOOL;
	tonPressHingGas: TON;
	bErrValveGas: BOOL;
	WarningGasPorog1: Warning_FB;
	bErrGasPorog1: BOOL;
	BlockGasPorog2: Block_FB;
	bErrGasPorog2: BOOL;
	InvAlarmFireBlokABGM: InvAlarm_FB;
	InvAlarmFireHangarGPA: InvAlarm_FB;
	bErrFireHangarGPA: BOOL;
	bErrFireBlokABGM: BOOL;
	BlockPressDropAirFilter: Block_FB;
	bErrPressDropAirFilter: BOOL;
	bErrBK101_tempTO1: BOOL;
	BlockErrBK101_tempTO1: Block_FB;
	BlockErrBK102_tempTO2: Block_FB;
	BlockErrBK202_tempTO4: Block_FB;
	BlockErrBK201_tempTO3: Block_FB;
	bErrBK201_tempTO3: BOOL;
	bErrBK102_tempTO2 : BOOL;
	bErrBK202_tempTO4: BOOL;
	BlockBK101_tempTO1: Block_FB;
	BlockErrValveGas : Block_FB;
	bErr350_tempTO1: BOOL;
	BlockBK102_tempTO2: Block_FB;
	bErr350_tempTO2: BOOL;
	bErr350_tempTO3: BOOL;
	bErr350_tempTO4: BOOL;
	BlockBK202_tempTO4: Block_FB;
	BlockBK201_tempTO3: Block_FB;
	WarningHighCH4Porog1: Warning_FB;
	bErrHighCH4Porog: BOOL;
	bErrHighCH4Porog2: BOOL;
	BlockHighCH4Porog2: Block_FB;
	WarningTempGas: Warning_FB;
	bErrTempGas: BOOL;
	BlockErrBK1_tempGas: Block_FB;
	bErrBK1_tempGas: BOOL;
	BlockErrBK2_tempAir: Block_FB;
	bErrBK2_tempAir: BOOL;
	WarningBK2_tempAir: Warning_FB;
	bErr60TempAir: BOOL;
	WarningBK2_tempAir70: Warning_FB;
	bErr70TempAir: BOOL;
	BlockBK2_tempAir80: Block_FB;
	bErr80tempAir: BOOL;
	BlockBK3_tempCO: Block_FB;
	bErrBK3_tempCO: BOOL;
	WarningBK3_tempCO10: Warning_FB;
	bErr10TempCO: BOOL;
	tonTempCO120 : TON;
	BlockTempCO120 : Block_FB;
	bErrTempCO120 : BOOL;
	WarningBK3_tempCO30: Warning_FB;
	bErr30TempCO: BOOL;
	BlockErrBP1_presAir: Block_FB;
	bErrBP1_presAir: BOOL;
	BlockErrBP2_presHing: Block_FB;
	bErrBP2_presHing: BOOL;
	BlockErrBP3_presLow: Block_FB;
	bErrBP3_presLow: BOOL;
	BlockBP101_PressDropTG1: Block_FB;
	bErrBP101_PressDropTG1: BOOL;
	BlockBP102_PressDropTG2: Block_FB;
	bErrBP102_PressDropTG2: BOOL;
	BlockBP201_PressDropTG3: Block_FB;
	bErrBP201_PressDropTG3: BOOL;
	BlockBP202_PressDropTG4: Block_FB;
	bErrBP202_PressDropTG4: BOOL;
	bErrPressDropTG1and2: BOOL;
	bErrPressDropTG3and4: BOOL;
	tonBP101_PressDropTG1 : TON;
	tonBP102_PressDropTG2 : TON;

	tonBP201_PressDropTG3 : TON;
	tonBP202_PressDropTG4 : TON;
	bErrBO1ob: BOOL; (*общая авария ВО не достигнута частота и авария*)
	bErrBO2ob: BOOL;
	BlockBP1PresHing : Block_FB;
	bErrBP1_Hing : BOOL;
	BlockBP2PresLow : Block_FB;
	bErrBP2_Low : BOOL;
	BlockBP2PresHing : Block_FB;
	bErrBP2_Hing : BOOL;
	tonBP3PresLow : TON;
	BlockBP3PresLow : Block_FB;
	bErrBP3_Low : BOOL;
	BlockBP3PresHing : Block_FB;
	bErrBP3_Hing : BOOL;
	bErrObGasValve : BOOL;
	bErrLine1 : BOOL;
	bErrLine2 : BOOL;
	bErrObBurner1 : BOOL;
	bErrObBurner2 : BOOL;
	bErrObBurner3 : BOOL;
	bErrObBurner4 : BOOL;
	bErrObBO1 : BOOL;
	bErrObBO2 : BOOL;
	bErrBB1and2 : BOOL;

	Mode5_15_PID : Mode5_15 ;
	bBlink: BOOL  := TRUE;
	ptBB : TON;
	Switcher: Switcher_FB;
	Heating : Heating_FB;

	bButStart: BOOL;
	bStopPanel: BOOL;
	bStartSAYdisc : BOOL;
	bStopSAYdisc : BOOL;
	bStartSAYmod : BOOL;
	bStopSAYmod : BOOL;
	bStatrAVGM : BOOL;
	bFanMax : BOOL;

	byMode : BYTE; (*режимы*)
	FanObduva1 : FanObduva_FB;
	wRateBO1 : WORD :=35;
	FanObduva2 : FanObduva_FB;
	wRateBO2 : WORD  :=35;

	PIDburner1and2 : PID_PWM_ASUPRO; (*PID_PWM_CE;*)
	bObduv : BOOL;

	RS_Obduv : RS;
(*Настройка ПИД 1*)
	SwitcherBurner1 : Switcher_FB;
	SwBurner1and2 : SwBurner_FB;
	ZadPowerBuner1 : ZadPower_FB;
	ZadPowerBuner2 : ZadPower_FB;

(*Настройка ПИД 2*)
	PIDburner3and4 : PID_PWM_ASUPRO;  (*PID_PWM_CE;*)
	SwitcherBurner3 : Switcher_FB;
	SwBurner3and4 : SwBurner_FB;
	ZadPowerBuner3 : ZadPower_FB;
	ZadPowerBuner4 : ZadPower_FB;

(*Наработка*)
	MotoHoursBurner1 : MotoHours_FB;
	MotoHoursBurner2 : MotoHours_FB;
	MotoHoursBurner3 : MotoHours_FB;
	MotoHoursBurner4 : MotoHours_FB;
	MotoHoursBO1 : MotoHours_FB;
	MotoHoursBO2 : MotoHours_FB;
	MotoHoursBB1 : MotoHours_FB;
	MotoHoursBB2 : MotoHours_FB;


	SAY_ModeSummer: BOOL;
	SAY_ModeHeadGPA: BOOL;

	SAY_FireHangarGPA: BOOL;
	SAY_FireBlokABGM: BOOL;
	SAY_HighCH4Porog1: BOOL;
	SAY_HighCH4Porog2: BOOL;
	SAY_StartBO1: BOOL;
	SAY_StartBO2: BOOL;
	SAY_StartBurner1: BOOL;
	SAY_StartBurner2: BOOL;
	SAY_StartBurner3: BOOL;
	SAY_StartBurner4: BOOL;
	ModeSummer: BOOL;
	ModeSummer2: BOOL;

	Period_PWM: INT :=200;  (*прямопропорциональное увеличичение периода и длительности команд УВ*)
	Temp_Dz: REAL :=1.0; (*гаа : зона нечуств ПИД-регуляторов горелок, град. *)
	FirstScan : BOOL := FALSE; 				(* флаг старта программы и записи первоначальных уставок *)
(*гаа используется только при отладке ППО в режиме эмуляции*)
	Temp_Kp: REAL := 0.1; (*гаа :коэф пропорц.  ПИД-регулятора, Кп = 0.1 *)
	Temp_Ki: REAL :=200;  (*гаа :коэф интегр.  ПИД-регулятора*)
	Temp_Kd: REAL;
	Temp_T: REAL;  (*используется только при отладке ППО в режиме эмуляции*)
END_VAR
(* @END_DECLARATION := '0' *)
(*--------------- гаа : настройка параметров при включении питания/сброса------------------------*)
IF NOT FirstScan THEN  (* выполнение действий при первом старте ППО*)
   (*Инициализация сохранённых значений уставок*)
	r4x37 := REAL_TO_WORD(wPID1prop * 100.0); (*гаа : на панели размерность Кп * 100*)
	r4x38 := wPID1intg ;
	r4x39 := wPID1diff ;

	r4x40  := REAL_TO_WORD(wPID2prop * 100.0);
	r4x41 := wPID2intg ;
	r4x42 := wPID2diff ;

	r4x35 := wPanelZad1;
	r4x36 := wPanelZad2;
	r4x26 := wYstavkaCO;

	r4x47	:= uiBurner1_FullMove; (*время полного хода горелки*)
	r4x48	:= uiBurner2_FullMove;
	r4x49	:= uiBurner3_FullMove;
	r4x50	:= uiBurner4_FullMove;
	r4x51	:= uiBurner1_Tmin;
	r4x52	:= uiBurner1_Tmax;
	r4x53	:= uiBurner2_Tmin;
	r4x54	:= uiBurner2_Tmax;
	r4x55	:= uiBurner3_Tmin;
	r4x56	:= uiBurner3_Tmax;
	r4x57	:= uiBurner4_Tmin;
	r4x58	:= uiBurner4_Tmax;

	FirstScan := TRUE;
END_IF

(*------------------------------------------------------------------------------------------------------------------*)
PLC_PRG.PLC_PRG.sayANDpanel();

IF b0x155 THEN
	PLC_PRG.PLC_PRG.ModeManual();
	b0x132:=TRUE; (*b0x155 кнопка перехода на панели*)
ELSE
	PLC_PRG.Alarm();
	PLC_PRG.ModeWork();
	PLC_PRG.Periphery();
	b0x132:=FALSE; (*индикатор ручного режима*)
END_IF


END_PROGRAM
ACTION	Alarm:
(*1*)(*Напряжения питания не в норме*);
Block_normVoltage(
	input:=NOT KU1_VoltageNormal,
	bError=> bErrVoltageNormal);

(*2*)(*Пропало основное напряжение питания*)
invAlarm_Voltage(
	inversion:= K2_OffVoltage,
	bError=> bErrVoltage);

(*3*)(*Неисправность электрообогрева секции обслуживания*)
IF K5_EleHeatingEnable AND NOT K3_ElectricalHeating
THEN bK3Off := TRUE;
ELSE bK3Off := FALSE;
END_IF

rtEnebleHeating(CLK:= K5_EleHeatingEnable,Q=> bEnebleTonHeating);
IF bEnebleTonHeating     (*Включить счётчик 300 сек на аварию эл обогревателя*)
THEN
	rTempCO:= BK3_tempCO; (*запомнить*)
	TonHeating.IN:= TRUE; (*запустить таймер*)
	bEnebleTonHeating:= FALSE; (*сброс *)
END_IF
IF NOT K5_EleHeatingEnable THEN TonHeating.IN:= FALSE; END_IF
TonHeating(pt:= t#10M);
TofHeating(IN:=TonHeating.Q, pt:=t#7s); (*задержка, чтобы Block_ElectricalHeating успел схватить аварию через t#5s*)
(*за 300 сек темп не поднялась на 2 гр*)
IF TofHeating.Q AND (rTempCO + 2 > BK3_tempCO) OR bK3Off
THEN
	Block_ElectricalHeating.input := TRUE; TonHeating.IN:= FALSE;
ELSE
	Block_ElectricalHeating.input := FALSE;
END_IF
Block_ElectricalHeating(bError=> bErrElectricalHeating);

(*4*)(*Неисправность цепей вентилятора обдува 1 (М100)*)
invAlarm_BO1Error(
	inversion:= K102_BO1Error,
	bError=> bErrBO1);
(*Готовность*)
UZnoReady_BO1Got(
	bStart:= K103_BO1 AND NOT K24_CostsAirNormalHude,
	bRediness:= K101_BO1Got,
	bError=> bNotBO1Got);

IF bErrBO1 OR bNotBO1Got
THEN bErrBO1ob := TRUE;
ELSE bErrBO1ob := FALSE;
END_IF

(*5*)(*Неисправность цепей вентилятора обдува 2 (М200)*)
invAlarm_BO2Error(
	inversion:= K202_BO2Error,
	bError=> bErrBO2);
(*Готовность*)
UZnoReady_BO2Got(
	bStart:= K203_BO2On AND NOT K24_CostsAirNormalHude,
	bRediness:= K201_BO2Got ,
	bError=> bNotBO2Got);

IF bErrBO2 OR bNotBO2Got
THEN bErrBO2ob := TRUE;
ELSE bErrBO2ob := FALSE;
END_IF

(*6*)(*Неисправность вытяжного вентилятора 1*)
AlarmAND_BB1On(
	input:= K7_BB1On ,
	inversion:= K6_BB1On,
	bError=> bErrBB1On);

(*7*)(*Неисправность вытяжного вентилятора 2*)
AlarmAND_BB2On(
	input:= K22_BB2On,
	inversion:= K23_BB2On,
	bError=> bErrBB2On);

(*8*)(*Неисправность клапана отбора воздуха (М4)*)

IF K8_AirBlidVelvOpen     (*Включить счётчик 120 сек на аварию эл обогревателя*)
THEN
rTempCOValve :=  BK3_tempCO; (*запомнить*)
TonHeatingValve.IN := TRUE;
bEnebleTonHeating := FALSE; (*сброс *)
ELSE TonHeatingValve.IN := FALSE;
END_IF
(*за 120 сек темп не поднялась на 2 гр*)
IF TonHeatingValve.Q AND (rTempCO + 2 > BK3_tempCO)
THEN Block_ValveHeating.input := TRUE;
ELSE  Block_ValveHeating.input := FALSE;
END_IF

TonHeatingValve(pt:= t#120s);
Block_ValveHeating(bError=> bErrValveHeating);

(*9*)(*Неисправность горелки 1*)
ErrorBurner1(
	start:= K104_StartBurner1,
	lampWork:= K105_Burner1Work,
	lampAlarm:= K106_Burner1Error OR (K105_Burner1Work AND bErr80tempAir),
	error=>bErrBurner1 );

(*10*)(*Неисправность горелки 2*)
ErrorBurner2(
	start:= K109_StartBurner2,
	lampWork:= K110_Burner2Work,
	lampAlarm:= K111_Burner2Error OR (K110_Burner2Work AND bErr80tempAir),
	error=> bErrBurner2 );

(*11*)(*Неисправность горелок 1 и 2*)
IF bErrBurner1 AND bErrBurner2
THEN bErrBurner1and2 := TRUE;
ELSE bErrBurner1and2 := FALSE;
END_IF

(*12*)(*Неисправность горелки 3*)
ErrorBurner3(
	start:= K204_StartBurner3 ,
	lampWork:= K205_Burner3Work,
	lampAlarm:= K206_Burner3Error OR (K205_Burner3Work AND bErr80tempAir),
	error=> bErrBurner3 );

(*13*)(*Неисправность горелки 4*)
ErrorBurner4(
	start:= K209_StartBurner4,
	lampWork:= K210_Burner4Work,
	lampAlarm:= K211_Burner4Error OR (K210_Burner4Work AND bErr80tempAir),
	error=> bErrBurner4);

(*14*)(*Неисправность горелок 3 и 4*)
IF bErrBurner3 AND bErrBurner4
THEN bErrBurner3and4 := TRUE;
ELSE bErrBurner3and4 := FALSE;
END_IF

(*15*)(*Неисправность отсечного газового клапана (М5)*)
IF K9_GasValveOpen AND BP2_presHing < 30
THEN tonPressHingGas.IN := TRUE;
ELSE tonPressHingGas.IN := FALSE;
END_IF

tonPressHingGas(PT := t#10s );


BlockErrValveGas(input:= tonPressHingGas.Q, bError=> bErrValveGas );

(*16*)(*Повышение оксида углерода в секции обслуживания порог 1*)
WarningGasPorog1(
	input:= K10_GasPorog1,
	bWarning=> bErrGasPorog1 );

(*17*)(*Повышение оксида углерода в секции обслуживания порог 2*)
BlockGasPorog2(
	input:= K11_GasPorog2 ,
	bError=> bErrGasPorog2 );

(*18*)(*Пожар в ангаре ГПА*)
InvAlarmFireHangarGPA(
	inversion:= K19_FireHangarGPA OR SAY_FireHangarGPA,
	bError=> bErrFireHangarGPA );

(*19*)(*Пожар в блоке АВГМ*)
InvAlarmFireBlokABGM(
	inversion:= K20_FireBlokABGM OR SAY_FireBlokABGM,
	bError=> bErrFireBlokABGM );

(*20*)(*Перепад давления на воздушном фильтре*)
BlockPressDropAirFilter(
	input:= K21_PressDropAirFilter ,
	bError=>bErrPressDropAirFilter );

(*21*)(*Неисправность датчика температуры теплообменника 1*)
BlockErrBK101_tempTO1 (
	input:= ErrBK101_tempTO1 >= 16#7,
	bError=> bErrBK101_tempTO1 );

(*22*)(*Неисправность датчика температуры теплообменника 2*)
BlockErrBK102_tempTO2 (
	input:= ErrBK102_tempTO2 >= 16#7,
	bError=> bErrBK102_tempTO2 );

(*23*)(*Неисправность датчика температуры теплообменника 3*)
BlockErrBK201_tempTO3 (
	input:= ErrBK201_tempTO3 >= 16#7,
	bError=> bErrBK201_tempTO3 );

(*24*)(*Неисправность датчика температуры теплообменника 4*)
BlockErrBK202_tempTO4 (
	input:= ErrBK202_tempTO4 >= 16#7,
	bError=> bErrBK202_tempTO4 );

(*25*)(*Перегрев теплообменника 1*)
BlockBK101_tempTO1 (
	input:= BK101_tempTO1 >= 350,
	bError=> bErr350_tempTO1 );

(*26*)(*Перегрев теплообменника 2*)
BlockBK102_tempTO2 (
	input:= BK102_tempTO2 >= 350,
	bError=> bErr350_tempTO2 );

(*27*)(*Перегрев теплообменника 3*)
BlockBK201_tempTO3 (
	input:= BK201_tempTO3 >= 350,
	bError=> bErr350_tempTO3 );

(*28*)(*Перегрев теплообменника 4*)
BlockBK202_tempTO4 (
	input:= BK202_tempTO4 >= 350,
	bError=> bErr350_tempTO4 );

(*29*)(*Загазованность по СН4 порог 1*)
WarningHighCH4Porog1(
	input:= K17_HighCH4Porog1 OR SAY_HighCH4Porog1,
	bWarning=> bErrHighCH4Porog );

(*30*)(*Загазованность по СН4 порог 2*)
BlockHighCH4Porog2(
	input:= K18_HighCH4Porog2 OR SAY_HighCH4Porog2,
	bError=> bErrHighCH4Porog2 );

(*31*)(*Неисправность датчика температуры газа*)
BlockErrBK1_tempGas(
	input:= ErrBK1_tempGas  >= 16#7,
	bError=> bErrBK1_tempGas);

(*32*)(*Температура газа не в норме*)
WarningTempGas(
	input:= BK1_tempGas < -5 OR  BK1_tempGas > 50,
	bWarning=> bErrTempGas );

(*33*)(*Неисправность датчика температуры воздуха на выходе АВГМ*)
BlockErrBK2_tempAir(
	input:= ErrBK2_tempAir  >= 16#7,
	bError=> bErrBK2_tempAir);

(*34*)(*Высокая температура на выходе теплогенератора 1 (ВК2)*)
WarningBK2_tempAir(
	input:= BK2_tempAir > 60,
	bWarning=> bErr60TempAir);

(*35*)(*Высокая температура на выходе теплогенератора 1 (ВК2)*)
WarningBK2_tempAir70(
	input:= BK2_tempAir > 70,
	bWarning=> bErr70TempAir);

(*36*)(*Аварийно высокая температура теплогенератора 1 (ВК2)*)
BlockBK2_tempAir80(
	input:= BK2_tempAir > 80,
	bError=> bErr80tempAir);

(*37*)(*Неисправность датчика температуры воздуха в секции обслуживания*)
BlockBK3_tempCO(
	input:= ErrBK3_tempCO  >= 16#7,
	bError=> bErrBK3_tempCO);

(*38*)(*Высокая температура воздуха в секции обслуживания*)
WarningBK3_tempCO30(
	input:= BK3_tempCO > 30,
	bWarning=> bErr30TempCO);

(*39*)(*Низкая температура воздуха в секции обслуживания*)
WarningBK3_tempCO10(
	input:= BK3_tempCO < 10,
	bWarning=> bErr10TempCO);

(*40*)(*Низкая температура воздуха в секции обслуживания во время работы АВГМ в течении 120 с.*)
IF bStatrAVGM AND bErr10TempCO
THEN tonTempCO120.IN := TRUE;
ELSE  tonTempCO120.IN := FALSE;
END_IF

tonTempCO120(PT:=t#120s );

BlockTempCO120(
	input:=tonTempCO120.Q ,
	bError=> bErrTempCO120 );

(*41*)(*Неисправность датчика давления воздуха в воздуховоде (ВР1)*)
BlockErrBP1_presAir(
	input:= ErrBP1_presAir  >= 16#7,
	bError=> bErrBP1_presAir);

(*42*)(*Неисправность датчика давления газа до регулятора (ВР2)*)
BlockErrBP2_presHing(
	input:= ErrBP2_presHing  >= 16#7,
	bError=> bErrBP2_presHing);

(*Высокое давление воздуха в воздуховоде (ВР1)*)
BlockBP1PresHing(
	input:= BP1_presAir > 800,
	bError=> bErrBP1_Hing);

(*43*)(*Низкое давление газа до регулятора*)
IF b0x141 AND (BP2_presHing <= 20)
OR b0x142 AND (BP2_presHing <= 20)
OR b0x144 AND (BP2_presHing <= 20)
OR b0x146 AND (BP2_presHing <= 20)
THEN BlockBP2PresLow.input := TRUE;
ELSE  BlockBP2PresLow.input := FALSE;
END_IF
BlockBP2PresLow(bError=> bErrBP2_Low);

(*44*)(*Высокое давление газа до регулятора*)
IF  BP2_presHing >=520
THEN BlockBP2PresHing.input := TRUE;
ELSE  BlockBP2PresHing.input := FALSE;
END_IF
BlockBP2PresHing(bError=> bErrBP2_Hing);

(*45*)(*Неисправность датчика давления газа до регулятора (ВР3)*)
BlockErrBP3_presLow(
	input:= ErrBP3_presLow  >= 16#7,
	bError=> bErrBP3_presLow);

(*46*)(*Низкое давление газа после регулятора *)
IF b0x141 AND (BP3_presLow < 4)
OR b0x142 AND (BP3_presLow < 4)
OR b0x144 AND (BP3_presLow < 4)
OR b0x146 AND (BP3_presLow < 4)
THEN tonBP3PresLow.IN := TRUE;
ELSE  tonBP3PresLow.IN := FALSE;
END_IF
tonBP3PresLow(PT:=t#1s);
BlockBP3PresLow(
	input:=tonBP3PresLow.Q ,
	bError=> bErrBP3_Low);

(*47*)(*Высокое давление газа после регулятора*)
IF b0x141 AND (BP3_presLow >= 25)
OR b0x142 AND (BP3_presLow >= 25)
OR b0x144 AND (BP3_presLow >= 25)
OR b0x146 AND (BP3_presLow >= 25)
THEN BlockBP3PresHing.input := TRUE;
ELSE  BlockBP3PresHing.input := FALSE;
END_IF
BlockBP3PresHing(bError=> bErrBP3_Hing);

(*48*)(*Перепад давления теплообменника 1*)
tonBP101_PressDropTG1 (in:= , PT:= T#30s);

IF K105_Burner1Work AND K103_BO1 AND NOT BP101_PressDropTG1 (*AND NOT K24_CostsAirNormalHude*)
THEN  tonBP101_PressDropTG1.IN:= TRUE;
ELSE  tonBP101_PressDropTG1.IN := FALSE;
END_IF

BlockBP101_PressDropTG1(input:= tonBP101_PressDropTG1.Q );

IF BlockBP101_PressDropTG1.bError
THEN bErrBP101_PressDropTG1 := TRUE;
ELSE bErrBP101_PressDropTG1 := FALSE;
END_IF

(*49*)(*Перепад давления теплообменника 2*)
tonBP102_PressDropTG2 (in:= , PT:= T#30s);

IF K110_Burner2Work AND K103_BO1 AND NOT BP102_PressDropTG2 (*AND NOT K24_CostsAirNormalHude*)
THEN   tonBP102_PressDropTG2.IN:= TRUE;
ELSE  tonBP102_PressDropTG2.IN := FALSE;
END_IF

BlockBP102_PressDropTG2(input:= tonBP102_PressDropTG2.Q );

IF BlockBP102_PressDropTG2.bError
THEN bErrBP102_PressDropTG2 := TRUE;
ELSE bErrBP102_PressDropTG2 := FALSE;
END_IF

(*50*)(*Перепад давления теплообменников 1 и 2*)
IF bErrBP101_PressDropTG1 AND bErrBP102_PressDropTG2
THEN bErrPressDropTG1and2 := TRUE;
ELSE bErrPressDropTG1and2 := FALSE;
END_IF

(*51*)(*Перепад давления теплообменника 3*)

tonBP201_PressDropTG3(in:= , PT:= T#30s);

IF K205_Burner3Work AND K203_BO2On AND NOT BP201_PressDropTG3 (*AND NOT K24_CostsAirNormalHude*)
THEN   tonBP201_PressDropTG3.IN:= TRUE;
ELSE  tonBP201_PressDropTG3.IN := FALSE;
END_IF

BlockBP201_PressDropTG3(input:= tonBP201_PressDropTG3.Q );

IF BlockBP201_PressDropTG3.bError
THEN bErrBP201_PressDropTG3 := TRUE;
ELSE bErrBP201_PressDropTG3 := FALSE;
END_IF

(*52*)(*Перепад давления теплообменника 4*)
tonBP202_PressDropTG4(in:= , PT:= T#30s);

IF K210_Burner4Work AND K203_BO2On AND NOT BP202_PressDropTG4 (*AND NOT K24_CostsAirNormalHude*)
THEN   tonBP202_PressDropTG4.IN:= TRUE;
ELSE  tonBP202_PressDropTG4.IN := FALSE;
END_IF

BlockBP202_PressDropTG4(input:= tonBP202_PressDropTG4.Q );

IF BlockBP202_PressDropTG4.bError
THEN bErrBP202_PressDropTG4 := TRUE;
ELSE bErrBP202_PressDropTG4 := FALSE;
END_IF

(*53*)(*Перепад давления теплообменников 3 и 4*)
IF bErrBP201_PressDropTG3 AND bErrBP202_PressDropTG4
THEN bErrPressDropTG3and4 := TRUE;
ELSE bErrPressDropTG3and4 := FALSE;
END_IF

PLC_PRG.AlarmOb;











END_ACTION

ACTION	AlarmOb:

(*Общие авария отключение питания*)
IF bErrVoltageNormal
OR bErrVoltage
OR bErrHighCH4Porog2
OR NOT  SB1_PressKeyErrorStop
OR bErrFireHangarGPA
OR bErrFireBlokABGM
THEN K1_AlarmOffVoltage:= TRUE;
ELSE K1_AlarmOffVoltage:= FALSE;
END_IF
(*неистравность двух ВВ и останов агрегата*)
IF bErrBB1On AND bErrBB2On
THEN bErrBB1and2 := TRUE;
ELSE bErrBB1and2 := FALSE;
END_IF

(*общии аварии для режима обогрев линия 1*)
IF bNotBO1Got
OR bErrBurner1and2
OR bErrBK101_tempTO1 AND bErrBK102_tempTO2
OR bErr350_tempTO1
OR bErr350_tempTO2
OR bErrBK1_tempGas
OR bErrBK2_tempAir
OR bErrBP2_Low
OR bErrBP2_Hing
OR bErrBP3_presLow
OR bErrBP3_Low
OR bErrBP3_Hing
OR bErrPressDropTG1and2
OR K1_AlarmOffVoltage (*не только отключит но и заблокирует*)
OR bErrBB1and2 (*Если неисправны оба ВВ то останов*)
OR bErrTempGas
OR bErrObGasValve
OR bErrBK3_tempCO
THEN bErrLine1 := TRUE;
ELSE bErrLine1 := FALSE;
END_IF

(*общии аварии для режима обогрев линия 2*)
IF bNotBO1Got
OR bErrBurner3and4
OR bErrBK201_tempTO3 AND bErrBK202_tempTO4
OR bErr350_tempTO3
OR bErr350_tempTO4
OR bErrBK1_tempGas
OR bErrBK2_tempAir
OR bErrBP2_Low
OR bErrBP2_Hing
OR bErrBP3_presLow
OR bErrBP3_Low
OR bErrBP3_Hing
OR bErrPressDropTG3and4
OR K1_AlarmOffVoltage (*не только отключит но и заблокирует*)
OR bErrBB1and2 (*Если неисправны оба ВВ то останов*)
OR bErrTempGas
OR bErrObGasValve
OR bErrBK3_tempCO
THEN bErrLine2 := TRUE;
ELSE bErrLine2 := FALSE;
END_IF

(*общая авария горелки 1*)
IF bErrBP101_PressDropTG1 OR bErrBurner1 OR bErrBK101_tempTO1
THEN bErrObBurner1 := TRUE;
ELSE  bErrObBurner1 := FALSE;
END_IF
(*общая авария горелки 2*)
IF bErrBP102_PressDropTG2 OR bErrBurner2 OR bErrBK102_tempTO2
THEN bErrObBurner2 := TRUE;
ELSE  bErrObBurner2 := FALSE;
END_IF

(*общая авария горелки 3*)
IF bErrBP201_PressDropTG3 OR bErrBurner3 OR bErrBK201_tempTO3
THEN bErrObBurner3 := TRUE;
ELSE  bErrObBurner3 := FALSE;
END_IF

(*общая авария горелки 4*)
IF bErrBP202_PressDropTG4 OR bErrBurner4 OR  bErrBK202_tempTO4
THEN bErrObBurner4 := TRUE;
ELSE  bErrObBurner4 := FALSE;
END_IF

(*общая авария ВО1*)
IF K1_AlarmOffVoltage
OR bErrPressDropAirFilter
OR bErrBP1_presAir
OR bErrBP1_Hing
OR bErrBO1ob
THEN bErrObBO1 := TRUE;
ELSE bErrObBO1 := FALSE;
END_IF

(*общая авария ВО2*)
IF K1_AlarmOffVoltage
OR bErrPressDropAirFilter
OR bErrBP1_presAir
OR bErrBP1_Hing
OR bErrBO1ob
THEN bErrObBO2 := TRUE;
ELSE bErrObBO2 := FALSE;
END_IF

(*сигнализации о аварии*)
IF bErrVoltageNormal OR bErrVoltage OR bErrElectricalHeating
OR bErrBO1ob OR bErrBO2ob OR bErrBB1On OR bErrBB2On
OR bErrBurner1 OR bErrBurner2 OR bErrBurner3 OR bErrBurner4
OR bErrValveGas OR bErrGasPorog2 OR bErrFireHangarGPA
OR bErrFireBlokABGM OR bErrPressDropAirFilter
OR bErrBK101_tempTO1 OR bErrBK102_tempTO2
OR bErrBK201_tempTO3 OR bErrBK202_tempTO4
OR bErr350_tempTO1 OR bErr350_tempTO2
OR bErr350_tempTO3 OR bErr350_tempTO4
 OR bErrHighCH4Porog2
OR bErrBK1_tempGas OR bErrTempGas
OR bErrBK2_tempAir OR bErr60TempAir OR bErr70TempAir
OR bErr80tempAir OR bErrBK3_tempCO OR bErr30TempCO
OR bErr10TempCO OR bErrBP1_presAir OR bErrBP1_Hing OR bErrBP2_presHing
OR bErrBP2_Low OR bErrBP2_Hing OR bErrBP3_presLow
OR bErrBP3_Low OR bErrBP3_Hing OR bErrBP101_PressDropTG1
OR bErrBP102_PressDropTG2 OR bErrBP201_PressDropTG3
OR bErrBP202_PressDropTG4 OR NOT SB1_PressKeyErrorStop
THEN K16_ABGMError := FALSE ;
ELSE K16_ABGMError := TRUE ;
END_IF

(*аварии ОГК*)
IF K1_AlarmOffVoltage
OR bErrBurner1and2 AND bErrBurner3and4 (*неисп. все горелки*)
OR bErrValveGas
OR bErrBP2_presHing
OR bErrBP2_Hing
OR bErrBP2_Low
OR bErrBP3_Low
OR bErrTempGas
OR bErrBK1_tempGas
THEN bErrObGasValve := TRUE;
ELSE bErrObGasValve := FALSE;
END_IF
END_ACTION

ACTION	ModeManual:
(*Выхода*)

K1_AlarmOffVoltage 		    := SEL (b0x91, FALSE, TRUE);
K5_EleHeatingEnable 		    := SEL (b0x88, FALSE, TRUE);
K4_EleHeatingOff 			    := SEL (b0x92, FALSE, TRUE);
K103_BO1 					    := SEL (b0x60, FALSE, TRUE);
K203_BO2On 				    := SEL (b0x61, FALSE, TRUE);
K7_BB1On 	     			    := SEL (b0x89, FALSE, TRUE);
K8_AirBlidVelvOpen		    := SEL (b0x90, FALSE, TRUE);
K104_StartBurner1 		           := SEL (b0x56, FALSE, TRUE);
K109_StartBurner2			    := SEL (b0x57, FALSE, TRUE);
K204_StartBurner3 			    := SEL (b0x58, FALSE, TRUE);
K209_StartBurner4			    := SEL (b0x59, FALSE, TRUE);
K107_minPowerBurner1	    := SEL (b0x62, FALSE, TRUE);
K108_maxPowerBurner1	     := SEL (b0x66, FALSE, TRUE);
K112_minPowerBurner2   	     := SEL (b0x63, FALSE, TRUE);
K113_maxPowerBurner2	     := SEL (b0x67, FALSE, TRUE);
K207_minPowerBurner3	     := SEL (b0x64, FALSE, TRUE);
K208_maxPowerBurner3 	     := SEL (b0x68, FALSE, TRUE);
K212_minPowerBurner4	     := SEL (b0x65, FALSE, TRUE);
K213_maxPowerBurner4	     := SEL (b0x69, FALSE, TRUE);
K9_GasValveOpen			    := SEL (b0x87, FALSE, TRUE);
K15_ABGMWork 			    := SEL (b0x94, FALSE, TRUE);
K16_ABGMError 			    := SEL (b0x95, FALSE, TRUE);
K22_BB2On 				    := SEL (b0x93, FALSE, TRUE);
K25_OnHeadDrainCondensat := SEL (b0x96, FALSE, TRUE);
(*Входа*)
b0x97 := SEL (SB4_ButStart, FALSE, TRUE);
b0x98 := SEL (SA1_WorkStop, FALSE, TRUE);
b0x99 := SEL (K2_OffVoltage, FALSE, TRUE);
b0x100 := SEL (K3_ElectricalHeating, FALSE, TRUE);
b0x85 := SEL ( K101_BO1Got, FALSE, TRUE);
b0x79 := SEL (NOT K102_BO1Error, FALSE, TRUE);
b0x86 := SEL (K201_BO2Got, FALSE, TRUE);
b0x80 := SEL (NOT K202_BO2Error, FALSE, TRUE);
b0x101 := SEL (K6_BB1On, FALSE, TRUE);
b0x81 := SEL (K105_Burner1Work, FALSE, TRUE);
b0x75 := SEL (K106_Burner1Error, FALSE, TRUE);
b0x82 := SEL (K110_Burner2Work, FALSE, TRUE);
b0x76 := SEL (K111_Burner2Error, FALSE, TRUE);
b0x83 := SEL (K205_Burner3Work, FALSE, TRUE);
b0x77 := SEL (K206_Burner3Error, FALSE, TRUE);
b0x84 := SEL (K210_Burner4Work, FALSE, TRUE);
b0x78 := SEL (K211_Burner4Error, FALSE, TRUE);
b0x102 := SEL (K10_GasPorog1, FALSE, TRUE);
b0x103 := SEL (K11_GasPorog2, FALSE, TRUE);
b0x104 := SEL (K12_StartABGM, FALSE, TRUE);
b0x105 := SEL (K13_ModeSummer, FALSE, TRUE);
b0x106 := SEL (K14_ModeHeadGPA, FALSE, TRUE);
b0x107 := SEL (K17_HighCH4Porog1, FALSE, TRUE);
b0x108 := SEL (K18_HighCH4Porog2, FALSE, TRUE);
b0x109 := SEL (K19_FireHangarGPA, FALSE, TRUE);
b0x110 := SEL (K20_FireBlokABGM, FALSE, TRUE);
b0x111 := SEL (K21_PressDropAirFilter, FALSE, TRUE);
b0x112 := SEL (KU1_VoltageNormal, FALSE, TRUE);
b0x113 := SEL (SB1_PressKeyErrorStop, FALSE, TRUE);
b0x114 := SEL (K23_BB2On, FALSE, TRUE);
b0x74 := SEL (K24_CostsAirNormalHude, FALSE, TRUE);
b0x70 := SEL (BP101_PressDropTG1, FALSE, TRUE);
b0x71 := SEL (BP102_PressDropTG2, FALSE, TRUE);
b0x72 := SEL (BP201_PressDropTG3, FALSE, TRUE);
b0x73 := SEL (BP202_PressDropTG4, FALSE, TRUE);

(*Задание частоты*)


(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(35);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(35);
END_IF
END_ACTION

ACTION	ModeWork:
(*Блокировка режимов*)
IF b0x136 AND b0x141
OR b0x136 AND b0x142
OR b0x136 AND b0x144
OR b0x136 AND b0x146
OR b0x139 AND b0x141
OR b0x139 AND b0x142
OR b0x139 AND b0x144
OR b0x139 AND b0x146
OR b0x136 AND b0x139
OR b0x141 AND b0x144
OR b0x141 AND b0x146
OR b0x142 AND b0x144
OR b0x142 AND b0x146
THEN b0x136 := FALSE; b0x139 := FALSE; b0x141 := FALSE; b0x144 := FALSE; b0x142 := FALSE;  b0x146 := FALSE;   b0x54 := TRUE;
ELSE b0x54 := FALSE; byMode := 0;
END_IF

(*серая кнопка*)
IF b0x136  AND bStatrAVGM (*b0x136 вент обд 1*)
OR b0x139 AND bStatrAVGM (*b0x139 вент обд 2*)
OR b0x141 AND bStatrAVGM (*b0x141 гор 1*)
OR b0x144  AND bStatrAVGM (*b0x144 гор 3*)
OR b0x142 AND bStatrAVGM (*b0x142 гор 2*)
OR b0x146 AND bStatrAVGM (*b0x146 гор 4*)
THEN b0x138 := TRUE;
ELSE b0x138 := FALSE;
END_IF

(*режим лето*)
IF K13_ModeSummer AND NOT bErrObBO1 OR SAY_ModeSummer AND NOT bErrObBO1 (*запустить от режима лето, *)
THEN ModeSummer :=TRUE; b0x116 := TRUE;
ELSIF bErrObBO1 AND NOT bErrObBO2 (*запустить от режима лето, если неисправен ВО1 *)
THEN ModeSummer2 :=TRUE; b0x116 := TRUE;
ELSE ModeSummer := FALSE; ModeSummer2 :=FALSE; b0x116 := FALSE;
END_IF

(*Пуск в режимов*)
IF bStatrAVGM
THEN
	IF b0x136 AND NOT bErrObBO1 OR ModeSummer OR SAY_StartBO1 AND NOT bErrObBO1(*BO 1*)
	THEN byMode := 1;
	END_IF
	IF b0x139 AND NOT bErrObBO2 OR ModeSummer2 OR SAY_StartBO2 AND NOT bErrObBO2 (*BO 2*)
	THEN byMode := 2;
	END_IF

		IF b0x141 AND NOT bErrLine1 OR SAY_StartBurner1 AND NOT bErrLine1 (*гор 1*)
		THEN byMode := 3;
		END_IF
		IF b0x142   AND NOT bErrLine1 OR SAY_StartBurner2 AND NOT bErrLine1(*гор  2*)
		THEN byMode := 4;
		END_IF
		IF b0x141  AND b0x142   AND NOT bErrLine1 (*гор 1and2*)
		THEN byMode := 5;
		END_IF

			IF b0x144 AND NOT bErrLine2 OR SAY_StartBurner3 AND NOT bErrLine2 (*гор  3*)
			THEN byMode := 6;
			END_IF
			IF b0x146 AND NOT bErrLine2 OR SAY_StartBurner4 AND NOT bErrLine2 (*гор  4*)
			THEN byMode := 7;
			END_IF
			IF b0x144 AND b0x146 AND NOT bErrLine2 (*гор 3and4*)
			THEN byMode := 8;
			END_IF
ELSE byMode := 0;
END_IF

(*запуск ПИД если выбран один из режимов обогрева 1 линии*)
IF byMode = 3 OR byMode = 4 OR byMode = 5
THEN PIDburner1and2.AVT_REG := TRUE;
ELSE PIDburner1and2.AVT_REG := FALSE;
END_IF

PIDburner1and2(
	ACTUAL:= Mode5_15_PID.wYstavkaPID_FB, (*Temp_T*)
	SET_POINT:= Mode5_15_PID.wZadaniePID_FB,
	KP:= wPID1prop, (* Temp_Kp*)
	TN:= wPID1intg, (* Temp_Ki*)
	TV:=  wPID1diff, (*Temp_Kd*)
	D_ZONE:= Temp_Dz ,   (*гаа = 2 С*)
	kn_RUCH_Y_UP:= ,
	kn_RUCH_Y_DOWN:= ,
	Time_PWM:= Period_PWM  ); (*прямопропорциональное увеличичение периода И длительности команд!- бессмысленно, при любом его значении результат: одинаковое перерегулирование ОР.
								Используем для задания периода команд УВ, длительность команд УВ ограничеваем в ZadPowerBunerХ(ZadPower_FB).t_max*)

(*
PIDburner1and2(
	ACTUAL:= Temp_T,
	SET_POINT:= Mode5_15_PID.wZadaniePID_FB,
	KP:=  Temp_Kp,
	TN:=  Temp_Ki,
	TV:=  Temp_Kd,
	D_ZONE:= Temp_Dz ,   (*гаа = 2 С*)
	kn_RUCH_Y_UP:= ,
	kn_RUCH_Y_DOWN:= ,
	Time_PWM:= Period_PWM  ); (*гаа : период подачи команды(импульсов) ПИД-ом, в циклах ППО ПЛК, а  длительность импульса расчитывает ПИД .   Заводская была = 500*)
							  (*гаа 130 циклов = 130*0,3 = 39 с*, соотв-ет макс. длительности команды и должен быть не более времени полного хода горелки(2с меандр * 20с) от 0% до 100% *)
*)

SwBurner1and2(
	bInput1:= (byMode = 3 OR byMode = 5),
	bInput2:= (byMode = 4 OR byMode = 5),
	rZad1:= ZadPowerBuner1.rCur_power,
	rZad2:= ZadPowerBuner2.rCur_power,
	Y_UP:= PIDburner1and2.Y_UP,
	Y_DOWN:= PIDburner1and2.Y_DOWN,
	bD_Zone:=PIDburner1and2.D_ZONE_,
	bInWork1:= K105_Burner1Work,
	bInWork2:= K110_Burner2Work,
	bInError1 :=  bErrObBurner1, (*гаа*)(*SwitcherBurner1.bOutError1,*)
	bInError2 := bErrObBurner2, (*гаа*)(*SwitcherBurner1.bOutError2,*)
	wHourBurner1 := wHourBurner1,
	wHourBurner2 := wHourBurner2,
	rTempTO1 :=  BK101_tempTO1,
	rTempTO2 := BK102_tempTO2);

ZadPowerBuner1(
	bStart:= SwBurner1and2.bStartPower1,
	bPIDmax:= SwBurner1and2.bPIDmax1,
	bPIDmin:= SwBurner1and2.bPIDmin1,
	t_min:= uiBurner1_Tmin,
	t_max:= uiBurner1_Tmax,
	uiFullMove:= uiBurner1_FullMove,
	bOpen1=> K108_maxPowerBurner1,
	bClose1=> K107_minPowerBurner1,
	bStartBurner => K104_StartBurner1);

ZadPowerBuner2(
	bStart:= SwBurner1and2.bStartPower2,
	bPIDmax:= SwBurner1and2.bPIDmax2,
	bPIDmin:= SwBurner1and2.bPIDmin2,
	t_min:= uiBurner2_Tmin,
	t_max:= uiBurner2_Tmax,
	uiFullMove:= uiBurner2_FullMove,
	bOpen1=> K113_maxPowerBurner2,
	bClose1=> K112_minPowerBurner2,
	bStartBurner => K109_StartBurner2);

(*
(*запуск ВО1*)
IF byMode =1 AND NOT bErrBO1ob   (*гаа : если режим =1 - Вентиляция линии 1*)
OR K104_StartBurner1 AND (BK101_tempTO1>40) AND NOT bErrBO1ob  (*гаа : если включена Г1 и ТО > 40 и нет аварии ВО1*)
OR K109_StartBurner2 AND (BK102_tempTO2>40) AND NOT bErrBO1ob
OR RS_Obduv.Q1 AND b0x141  AND NOT bErrBO1ob
OR RS_Obduv.Q1  AND b0x142 AND NOT bErrBO1ob  (*переключатель обдува*)
THEN FanObduva1.bRun := TRUE; 				(*гаа : включить ВО1 *)
ELSE FanObduva1.bRun := FALSE;
END_IF
*)
(*----------------------гаа : АВТ управл. ВО1 , как ИМ 1х0*)
FanObduva1.bRun := FanObduva1.bRun
AND NOT (BK101_tempTO1 < 30 AND BK102_tempTO2 < 30 AND  (b0x141 OR b0x142) AND NOT bStatrAVGM)  (*ВО1 выключить если То1 И ТО2 < 30 C* И разрешены режимы обогрева Г1 или Г2 И АВГМ не работает*)
AND NOT bErrBO1ob 	(* ВО1 выключить если Ошибка ВО1 или нажаты кнопки АО.*)
AND NOT (NOT bStatrAVGM  AND NOT (b0x141 OR b0x142)) (* ВО1 выключить если Выключен АВГМ И НЕ включен режим Г1 или Г2.*)
(*AND NOT  (byMode =0)  AND NOT (b0x141 OR b0x142)*)
(*OR (byMode =1) AND NOT bErrBO1ob*) (*ВО1 включить если режим = 1 - вентиляция Линия 1*)
OR b0x136 AND bStatrAVGM AND NOT bErrBO1ob	(*ВО1 включить если режим = 1 - вентиляция Линия 1 И Пуск АВГМ  И нет ошибки ВО1*)
OR (((BK101_tempTO1>40) OR  (BK102_tempTO2>40)) AND ((b0x141 OR b0x142) AND bStatrAVGM AND NOT bErrBO1ob)); (*ВО1 включить если То1 или ТО2 > 40 C* И режимы работы И НЕ выключен АВГМ И НЕ ошибка ВО1*)
(*----------------------гаа *)


(*изменение частоты и запуск*)
FanObduva1(
	bModeMax:= bFanMax,
	bOutStart=> K103_BO1,   (*гаа : управляющий DO *)
	wRate=> wRateBO1 );

(*запуск ПИД если выбран один из режимов обогрева 2 линии*)
IF byMode >=6
THEN PIDburner3and4.AVT_REG := TRUE;
ELSE PIDburner3and4.AVT_REG := FALSE;
END_IF

(*гаа*) (*
SwitcherBurner3(
	bError1 := bErrObBurner3 ,
	bError2 := bErrObBurner4 );
*)
PIDburner3and4(
	ACTUAL:= Mode5_15_PID.wYstavkaPID_FB,
	SET_POINT:= Mode5_15_PID.wZadaniePID_FB,
	KP:= wPID2prop,
	TN:= wPID2intg,
	TV:=  wPID2diff,
	D_ZONE:= Temp_Dz,			(*гаа - зона нечуств, С*)
	kn_RUCH_Y_UP:= ,
	kn_RUCH_Y_DOWN:= ,
	Time_PWM:= Period_PWM  );

SwBurner3and4(
	bInput1:= (byMode = 6 OR byMode = 8),
	bInput2:= (byMode = 7 OR byMode = 8),
	rZad1:= ZadPowerBuner3.rCur_power,
	rZad2:= ZadPowerBuner4.rCur_power,
	Y_UP:= PIDburner3and4.Y_UP,
	Y_DOWN:= PIDburner3and4.Y_DOWN,
	bD_Zone:=PIDburner3and4.D_ZONE_,
	bInWork1:= K205_Burner3Work,
	bInWork2:= K210_Burner4Work,
	bInError1 :=  bErrObBurner3, (*SwitcherBurner3.bOutError1,*)
	bInError2 := bErrObBurner4, (*SwitcherBurner3.bOutError2,*)
	wHourBurner1 := wHourBurner3,
	wHourBurner2 := wHourBurner4,
	rTempTO1 :=  BK201_tempTO3,
	rTempTO2 := BK202_tempTO4);

ZadPowerBuner3(
	bStart:= SwBurner3and4.bStartPower1,
	bPIDmax:= SwBurner3and4.bPIDmax1,
	bPIDmin:= SwBurner3and4.bPIDmin1,
	t_min:= uiBurner3_Tmin,
	t_max:= uiBurner3_Tmax,
	uiFullMove:= uiBurner3_FullMove,
	bOpen1=>  K208_maxPowerBurner3,
	bClose1=> K207_minPowerBurner3,
	bStartBurner => K204_StartBurner3);

ZadPowerBuner4(
	bStart:= SwBurner3and4.bStartPower2,
	bPIDmax:= SwBurner3and4.bPIDmax2,
	bPIDmin:= SwBurner3and4.bPIDmin2,
	t_min:= uiBurner4_Tmin,
	t_max:= uiBurner4_Tmax,
	uiFullMove:= uiBurner4_FullMove,
	bOpen1=> K213_maxPowerBurner4,
	bClose1=> K212_minPowerBurner4,
	bStartBurner => K209_StartBurner4);

(*
(*запуск ВО2*)
IF byMode =2 AND NOT bErrBO2ob
OR K204_StartBurner3 AND (BK201_tempTO3>40) AND NOT bErrBO2ob
OR K209_StartBurner4 AND (BK202_tempTO4>40) AND NOT bErrBO2ob
OR RS_Obduv.Q1 AND b0x144  AND NOT bErrBO2ob
OR RS_Obduv.Q1  AND b0x146 AND NOT bErrBO2ob  (*переключатель обдува*)
THEN FanObduva2.bRun := TRUE;
ELSE FanObduva2.bRun := FALSE;
END_IF
*)
(*----------------------гаа : АВТ управл. ВО2 , как ИМ 1х0*)
FanObduva2.bRun := FanObduva2.bRun
AND NOT (BK201_tempTO3 < 30 AND BK202_tempTO4 < 30 AND (b0x144 OR b0x146)  AND NOT bStatrAVGM)	(*ВО1 выключить если То1 И ТО2 < 30 C* И режимы обогрева Г3 или Г4 И не работает АВГМ*)
AND NOT bErrBO2ob(* ВО2 выключить если Ошибка ВО2 или нажаты кнопки АО.*)
AND NOT (NOT bStatrAVGM  AND NOT (b0x144 OR b0x146) ) (* ВО1 выключить если Выключен АВГМ И НЕ включен режим Г3 или Г4.*)
OR b0x139 AND bStatrAVGM AND NOT bErrBO2ob	(*ВО1 включить если режим = 1 - вентиляция Линия 1 И Пуск АВГМ  И нет ошибки ВО1*)
OR (((BK201_tempTO3 > 40) OR  (BK202_tempTO4 > 40)) AND ((b0x144 OR b0x146) AND bStatrAVGM AND NOT bErrBO2ob)); (*ВО2 включить если То3 или ТО4 > 40 C* И режимы работы И НЕ выключен АВГМ И НЕ ошибка ВО2*)
(*----------------------гаа *)

FanObduva2(
	bRun:= ,
	bModeMax:= bFanMax,
	bOutStart=> K203_BO2On ,
	wRate=> wRateBO2 );



(*обдув*)
IF K104_StartBurner1 OR K109_StartBurner2 OR K204_StartBurner3 OR K209_StartBurner4   (*гаа: работает любая горелка*)
THEN bObduv :=TRUE; (*включет переключатель RS*)
ELSE bObduv :=FALSE;
END_IF

(*
IF BK101_tempTO1<30 AND  BK102_tempTO2<30 AND BK201_tempTO3<30 AND BK202_tempTO4<30   (*гаа : если все То <30 то сброс обдува - выключить ВО у кот. работает горелка*)
THEN  RS_Obduv.RESET1:= TRUE; (*будет держать переключатель выключенным пака тамп не опустится*)
ELSE RS_Obduv.RESET1 := FALSE;
END_IF
RS_Obduv(SET:= bObduv );

*)

(*подача сигнала нормальный останов*)
IF (((BK101_tempTO1 > 30 OR BK102_tempTO2 > 30) AND (b0x141 OR b0x142) AND K103_BO1) OR
	((BK201_tempTO3 > 30 OR BK202_tempTO4 > 30) AND (b0x144 OR b0x146) AND K203_BO2On)) AND NOT bStatrAVGM
THEN b0x119 := TRUE;  (*газ - индикация на панели НО*)
ELSE b0x119 := FALSE;
END_IF


END_ACTION

ACTION	Periphery:
(*запус АВГМ*)
IF SA1_WorkStop
THEN
	IF SB4_ButStart AND (b0x136 OR b0x139 OR b0x141 OR b0x142 OR b0x144 OR b0x146) (*алгоритв вкл от кнопки на ШУ*)
	THEN bButStart := TRUE;
			b0x115 := TRUE; (*отображение кнопки стоп на панели*)
	END_IF
		IF  b0x153 (*кнопка стоп на панели*)
		THEN bStopPanel := TRUE; bButStart:= FALSE;
		ELSE bStopPanel := FALSE;
		END_IF
		IF b0x153 (*выключить подсветку кнопки и сбросить кнопку стоп*)
		THEN b0x115 := FALSE; b0x153 := FALSE;
		END_IF

			IF K12_StartABGM (*алгоритм вкл от САУ дискретом*)
			THEN bStartSAYdisc := TRUE;
			END_IF
				IF bStartSAYdisc AND NOT K12_StartABGM
				THEN bStopSAYdisc := TRUE; bStartSAYdisc:= FALSE;
				ELSE bStopSAYdisc := FALSE;
				END_IF
			IF bInReg12_0 (*алгоритм вкл от САУ Модбас*)
			THEN   bStartSAYmod:= TRUE;
			END_IF
				IF bStartSAYmod AND NOT bInReg12_0
				THEN bStopSAYmod := TRUE; bStartSAYmod:= FALSE;
				ELSE bStopSAYmod := FALSE;
				END_IF
(*сброс всего натыконого, при переводе переключателя в останов*)
ELSE bStopPanel := TRUE; bStopSAYdisc := TRUE; bStopSAYmod := TRUE;
	    bButStart:= FALSE; bStartSAYdisc := FALSE; bStartSAYmod := FALSE;
END_IF

	IF (bButStart OR bStartSAYdisc OR bStartSAYmod) AND NOT (bErrLine1 OR bErrLine2) AND NOT (bErrObBO1 OR bErrObBO2)
	THEN bStatrAVGM := TRUE; K15_ABGMWork := TRUE;
	ELSIF bStopPanel OR bStopSAYdisc OR bStopSAYmod OR bErrLine1 OR bErrLine2 OR bErrObBO1 OR bErrObBO2
	THEN bStatrAVGM := FALSE; K15_ABGMWork := FALSE;
	END_IF

(*сборка на запуск макcимального режима*)
IF K24_CostsAirNormalHude OR bInReg12_3
THEN bFanMax := TRUE;
ELSE bFanMax := FALSE;
END_IF

(*вентиляторы обдува*)
(*за переключение отвечает Switcher.*
а Конструкция ниже отвечает за первоначальный запуск ВВ1 и дальнейшее переключение*)
IF   bBlink AND NOT b0x134
OR  ptBB.Q AND NOT b0x135
OR b0x134 AND b0x135
THEN Switcher.bStart1 := TRUE;
ELSE Switcher.bStart1 := FALSE;
END_IF
IF b0x134 OR  b0x135
THEN bBlink:= FALSE; ptBB.IN := TRUE;
ELSIF NOT b0x134
THEN ptBB.IN := FALSE;  bBlink:= TRUE;
END_IF

ptBB(PT:= t#500ms ); (*Задержка времена т.к. bStart1 не успевает перезапустится *)

Switcher(
	bStart2:= b0x135  ,
	bError1:= bErrBB1On ,
	bError2:= bErrBB2On,
	bStart_out1_2:= ,
	bOut1=> K7_BB1On,
	bOut2=> K22_BB2On);

IF bErrGasPorog1 OR bErrHighCH4Porog OR bErr30TempCO
THEN Switcher.bStart_out1_2 := TRUE;
ELSE Switcher.bStart_out1_2 := FALSE;
END_IF

(*задание температурных режимов*)


Mode5_15_PID(
	bSignalSAY:= ,
	bSignalDiscret:= K14_ModeHeadGPA OR SAY_ModeHeadGPA,
	bWork1:= b0x150 ,
	bWork2:=  b0x151,
	reTempRoom:= TempRoom,
	reTempExit:= BK2_tempAir,
	wPanelZad1:= r4x35,
	wPanelZad2:= r4x36,
	bPanelTableZad=> b0x149 ,
	bPanelTable5_15=>  b0x148,
	wZadaniePID_FB=> ,
	wYstavkaPID_FB=> );

(*обогрев*)

Heating(
	bMode_FB:= NOT ModeSummer,
	wTempCO:= BK3_tempCO ,
	wYstPanel:= r4x26,
	bErrorHeating:= ,
	bErrorVolveAir:= ,
	bHeatingEneble=>K5_EleHeatingEnable ,
	bHeatingOff=> K4_EleHeatingOff,
	bVolveAirEneble=> K8_AirBlidVelvOpen);

(*газовый клапан*)
IF NOT bErrObGasValve AND b0x141
OR NOT bErrObGasValve AND b0x142
OR NOT bErrObGasValve AND b0x144
OR NOT bErrObGasValve AND b0x146
THEN K9_GasValveOpen := TRUE;
ELSE K9_GasValveOpen := FALSE;
END_IF

(*обогрев слива конденсата. если нет режима лето значит агрегат работает в режиме обогрев
и требуется обогрев конденсата*)
IF NOT K13_ModeSummer
THEN K25_OnHeadDrainCondensat := TRUE;
ELSE K25_OnHeadDrainCondensat := FALSE;
END_IF


END_ACTION

ACTION	sayANDpanel:
(*передача данных в панель аварии*)
b0x1 := SEL (bErrVoltageNormal, FALSE, TRUE);
b0x2 := SEL (bErrVoltage, FALSE, TRUE);
b0x3 := SEL (bErrElectricalHeating, FALSE, TRUE);
b0x4 := SEL (bErrBO1ob, FALSE, TRUE);
b0x5 := SEL (bErrBO2ob, FALSE, TRUE);
b0x6 := SEL (bErrBB1On, FALSE, TRUE);
b0x7 := SEL (bErrBB2On, FALSE, TRUE);
b0x8 := SEL (bErrValveHeating, FALSE, TRUE);
b0x9 := SEL (bErrBurner1, FALSE, TRUE);
b0x10 := SEL (bErrBurner2, FALSE, TRUE);
b0x11 := SEL (bErrBurner1and2, FALSE, TRUE);
b0x12 := SEL (bErrBurner3, FALSE, TRUE);
b0x13 := SEL (bErrBurner4, FALSE, TRUE);
b0x14 := SEL (bErrBurner3and4, FALSE, TRUE);
b0x15 := SEL (bErrObGasValve, FALSE, TRUE);
b0x16 := SEL (bErrGasPorog1, FALSE, TRUE);
b0x17 := SEL (bErrGasPorog2, FALSE, TRUE);
b0x18 := SEL (bErrFireHangarGPA, FALSE, TRUE);
b0x19 := SEL (bErrFireBlokABGM, FALSE, TRUE);
b0x20 := SEL (bErrPressDropAirFilter, FALSE, TRUE);
b0x21 := SEL (bErrBK101_tempTO1, FALSE, TRUE);
b0x22 := SEL (bErrBK102_tempTO2, FALSE, TRUE);
b0x23 := SEL (bErrBK201_tempTO3, FALSE, TRUE);
b0x24:= SEL (bErrBK202_tempTO4, FALSE, TRUE);
b0x25 := SEL (bErr350_tempTO1, FALSE, TRUE);
b0x26 := SEL (bErr350_tempTO2, FALSE, TRUE);
b0x27 := SEL (bErr350_tempTO3, FALSE, TRUE);
b0x28 := SEL (bErr350_tempTO4, FALSE, TRUE);
b0x29 := SEL (bErrHighCH4Porog, FALSE, TRUE);
b0x30 := SEL (bErrHighCH4Porog2, FALSE, TRUE);
b0x31 := SEL (bErrBK1_tempGas, FALSE, TRUE);
b0x32 := SEL (bErrTempGas, FALSE, TRUE);
b0x33 := SEL (bErrBK2_tempAir, FALSE, TRUE);
b0x34 := SEL (bErr60TempAir, FALSE, TRUE);
b0x35 := SEL (bErr70TempAir, FALSE, TRUE);
b0x36 := SEL (bErr80tempAir, FALSE, TRUE);
b0x37 := SEL (bErrBK3_tempCO, FALSE, TRUE);
b0x38 := SEL (bErr30TempCO, FALSE, TRUE);
b0x39 := SEL (bErr10TempCO, FALSE, TRUE);
b0x40 := SEL (bErrTempCO120, FALSE, TRUE);
b0x41 := SEL (bErrBP1_presAir, FALSE, TRUE);
b0x42 := SEL (bErrBP2_presHing, FALSE, TRUE);
b0x43 := SEL ( bErrBP2_Low , FALSE, TRUE);
b0x44 := SEL (bErrBP2_Hing  , FALSE, TRUE);
b0x45 := SEL (bErrBP3_presLow, FALSE, TRUE);
b0x46 := SEL (bErrBP3_Low , FALSE, TRUE);
b0x47 := SEL (bErrBP3_Hing   , FALSE, TRUE);
b0x48 := SEL (bErrBP101_PressDropTG1, FALSE, TRUE);
b0x49 := SEL (bErrBP102_PressDropTG2, FALSE, TRUE);
b0x50 := SEL (bErrPressDropTG1and2, FALSE, TRUE);
b0x51 := SEL (bErrBP201_PressDropTG3, FALSE, TRUE);
b0x52 := SEL (bErrBP202_PressDropTG4, FALSE, TRUE);
b0x53 := SEL (bErrPressDropTG3and4, FALSE, TRUE);
b0x118:= SEL (bErrBP1_Hing, FALSE, TRUE);
b0x159 := SEL (SB1_PressKeyErrorStop, TRUE, FALSE);
b0x133 := SEL (K16_ABGMError, TRUE, FALSE);
(*инфа о включенных эл.*)

b0x117 := SEL (K7_BB1On, FALSE, TRUE);
b0x55 := SEL (K22_BB2On, FALSE, TRUE);
b0x120 := SEL (K103_BO1, FALSE, TRUE);
b0x121 := SEL (K203_BO2On, FALSE, TRUE);
b0x123 := SEL (K9_GasValveOpen, FALSE, TRUE);
b0x124 := SEL (BP101_PressDropTG1, FALSE, TRUE);
b0x125 := SEL (K105_Burner1Work, FALSE, TRUE);
b0x126 := SEL (BP201_PressDropTG3, FALSE, TRUE);
b0x127 := SEL (K205_Burner3Work, FALSE, TRUE);
b0x128 := SEL (BP102_PressDropTG2, FALSE, TRUE);
b0x129 := SEL (K110_Burner2Work, FALSE, TRUE);
b0x130 := SEL (BP202_PressDropTG4, FALSE, TRUE);
b0x131 := SEL (K210_Burner4Work, FALSE, TRUE);


IF K9_GasValveOpen AND NOT  bErrValveGas
THEN  b0x122 :=TRUE;
ELSE  b0x122 :=FALSE;
END_IF
(*зелёная кнопка*)
b0x137 := SEL (b0x136, FALSE, TRUE);
b0x140 := SEL (b0x139, FALSE, TRUE);
b0x154 := SEL (b0x142, FALSE, TRUE);
b0x145 := SEL (b0x144, FALSE, TRUE);
b0x143 := SEL (b0x141, FALSE, TRUE);
b0x147 := SEL (b0x146, FALSE, TRUE);

b0x156 := SEL (bButStart, FALSE, TRUE);
b0x157 := SEL (K12_StartABGM, FALSE, TRUE);
b0x158 := SEL (bInReg12_0, FALSE, TRUE);

r4x10 := REAL_TO_INT(BK101_tempTO1);
(*r4x11 := REAL_TO_INT();*)
r4x12 := REAL_TO_INT(BK102_tempTO2);
(*r4x13 := REAL_TO_INT(); *)
r4x14 := REAL_TO_INT(BK1_tempGas);
(*r4x15 := REAL_TO_INT(); *)
r4x16 := REAL_TO_INT(BP3_presLow);
r4x17 := REAL_TO_INT(BK201_tempTO3);
(*r4x18 := REAL_TO_INT();*)
r4x19 := REAL_TO_INT(BK202_tempTO4);
(*r4x20 := REAL_TO_INT();*)
r4x21 := REAL_TO_INT(BP2_presHing);
r4x22 := REAL_TO_INT(BP1_presAir);
r4x23 := REAL_TO_INT(BK2_tempAir);
r4x24 := REAL_TO_INT(TempRoom);
r4x25 := REAL_TO_INT(BK3_tempCO);

wPanelZad1 := r4x35; (*гаа : Чтение из панели*)
wPanelZad2 := r4x36;

(*PID*)

	wPID1prop := r4x37 / 100.0; (*гаа : на панели размерность Кп * 100*)
	wPID1intg   :=r4x38;
	wPID1diff    := r4x39;

	wPID2prop := r4x40  / 100.0;
	wPID2intg   := r4x41;
	wPID2diff    := r4x42;

(*Нработка*)
MotoHoursBurner1(bDeviceInWork:= K104_StartBurner1, byHour=> wHourBurner1 );
MotoHoursBurner2(bDeviceInWork:= K109_StartBurner2, byHour=> wHourBurner2);
MotoHoursBurner3(bDeviceInWork:= K204_StartBurner3, byHour=>wHourBurner3 );
MotoHoursBurner4(bDeviceInWork:= K209_StartBurner4, byHour=> wHourBurner4);
MotoHoursBO1(bDeviceInWork:= K103_BO1, byHour=> wHourBO1);
MotoHoursBO2(bDeviceInWork:= K203_BO2On, byHour=>wHourBO2);
MotoHoursBB1(bDeviceInWork:= K7_BB1On, byHour=> wHourBB1);
MotoHoursBB2(bDeviceInWork:= K22_BB2On, byHour=> wHourBB2);
r4x27	:= wHourBurner1;
r4x28	:= wHourBurner2 ;
r4x31	:= wHourBurner3 ;
r4x32	:= wHourBurner4 ;
r4x29	:= wHourBO1  ;
r4x33	:= wHourBO2  ;
r4x30	:= wHourBB1  ;
r4x34	:= wHourBB2  ;

r4x43	:= REAL_TO_INT(ZadPowerBuner1.rCur_power);
r4x44	:= REAL_TO_INT(ZadPowerBuner2.rCur_power);
r4x45	:= REAL_TO_INT(ZadPowerBuner3.rCur_power);
r4x46	:= REAL_TO_INT(ZadPowerBuner4.rCur_power);
uiBurner1_FullMove := r4x47;
uiBurner2_FullMove := r4x48;
uiBurner3_FullMove := r4x49;
uiBurner4_FullMove := r4x50;
uiBurner1_Tmin := r4x51;
uiBurner1_Tmax := r4x52;
uiBurner2_Tmin := r4x53;
uiBurner2_Tmax := r4x54;
uiBurner3_Tmin := r4x55;
uiBurner3_Tmax := r4x56;
uiBurner4_Tmin := r4x57;
uiBurner4_Tmax := r4x58;

(*Задание частоты*)
(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(wRateBO1);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(wRateBO2);
END_IF

(*САУ*)
wSAY_reg0 := REAL_TO_INT (BK101_tempTO1);
wSAY_reg1 := REAL_TO_INT (BK102_tempTO2);
wSAY_reg2 := REAL_TO_INT (BK201_tempTO3);
wSAY_reg3 := REAL_TO_INT (BK202_tempTO4);
wSAY_reg4 := REAL_TO_INT (BK1_tempGas);
wSAY_reg5 := REAL_TO_INT (BK2_tempAir);
wSAY_reg6 := REAL_TO_INT (BK3_tempCO);
wSAY_reg7 := REAL_TO_INT (BP1_presAir);
wSAY_reg8 := REAL_TO_INT (BP2_presHing);
wSAY_reg9 := REAL_TO_INT (BP3_presLow);

bOutReg10_0 := SEL (K1_AlarmOffVoltage  ,FALSE, TRUE);
bOutReg10_1 := SEL (K5_EleHeatingEnable  ,FALSE, TRUE);
bOutReg10_2 := SEL (K4_EleHeatingOff  ,FALSE, TRUE);
bOutReg10_3 := SEL (K103_BO1  ,FALSE, TRUE);
bOutReg10_4 := SEL (K203_BO2On  ,FALSE, TRUE);
bOutReg10_5 := SEL (K7_BB1On  ,FALSE, TRUE);
bOutReg10_6 := SEL (K8_AirBlidVelvOpen  ,FALSE, TRUE);
bOutReg10_7 := SEL (K104_StartBurner1  ,FALSE, TRUE);
bOutReg10_8 := SEL (K109_StartBurner2  ,FALSE, TRUE);
bOutReg10_9 := SEL (K204_StartBurner3  ,FALSE, TRUE);
bOutReg10_10 := SEL (K209_StartBurner4  ,FALSE, TRUE);
bOutReg10_11:= SEL ( K9_GasValveOpen ,FALSE, TRUE);
bOutReg10_12 := SEL (K16_ABGMError  ,TRUE, FALSE);
bOutReg10_13 := SEL (K22_BB2On  ,FALSE, TRUE);
bOutReg10_14 := SEL (K25_OnHeadDrainCondensat  ,FALSE, TRUE);
bOutReg10_15 := SEL ( K10_GasPorog1 ,FALSE, TRUE);
bOutReg11_0 := SEL ( K11_GasPorog2 ,FALSE, TRUE);
bOutReg11_1 := SEL ( SB1_PressKeyErrorStop ,TRUE, FALSE);
bOutReg11_2 := SEL ( bErrVoltage ,FALSE, TRUE);
bOutReg11_3 := SEL (bErrBO1ob  ,FALSE, TRUE);
bOutReg11_4 := SEL ( bErrBO2ob  ,FALSE, TRUE);
bOutReg11_5 := SEL ( bErrBurner1 ,FALSE, TRUE);
bOutReg11_6 := SEL ( bErrBurner2 ,FALSE, TRUE);
bOutReg11_7 := SEL ( bErrBurner3 ,FALSE, TRUE);
bOutReg11_8 := SEL ( bErrBurner4 ,FALSE, TRUE);



SAY_ModeSummer := SEL (  bInReg12_1,FALSE, TRUE);
SAY_ModeHeadGPA := SEL (  bInReg12_2,FALSE, TRUE);

SAY_FireHangarGPA  := SEL ( bInReg12_4 ,FALSE, TRUE);
SAY_FireBlokABGM := SEL ( bInReg12_5 ,FALSE, TRUE);
SAY_HighCH4Porog1 := SEL ( bInReg12_6 ,FALSE, TRUE);
SAY_HighCH4Porog2 := SEL ( bInReg12_7,FALSE, TRUE);

SAY_StartBO1 := SEL ( bInReg12_8 ,FALSE, TRUE);
SAY_StartBO2 := SEL ( bInReg12_9 ,FALSE, TRUE);
SAY_StartBurner1 := SEL ( bInReg12_10 ,FALSE, TRUE);
SAY_StartBurner2 := SEL ( bInReg12_11 ,FALSE, TRUE);
SAY_StartBurner3 := SEL ( bInReg12_12 ,FALSE, TRUE);
SAY_StartBurner4 := SEL ( bInReg12_13 ,FALSE, TRUE);




(*Задание частоты*)
(*Задание частоты ВО1*)
IF K103_BO1
THEN M100_fanSpeed := funUZ100_4_20mA(wRateBO1);
END_IF

(*Задание частоты ВО2*)
IF K203_BO2On
THEN M200_fanSpeed := funUZ200_4_20mA(wRateBO2);
END_IF




END_ACTION







